<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=0"><meta name="description" content="Objective-C中的内存管理 [ 张文轩 ] "><meta name="theme-color" content="#ebc65a"><title>Objective-C中的内存管理 [ 张文轩 ] </title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css"><script src="https://cdn.bootcss.com/highlight.js/9.6.0/highlight.min.js" defer></script><script src="/js/paper.js" defer></script><script src="https://www.googletagmanager.com/gtag/js?id=xx-xxxxxxx-xx" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'xx-xxxxxxx-xx');</script><link rel="stylesheet" href="/css/tocbot.css"><script src="/js/tocbot.js" defer></script><script>window.addEventListener('DOMContentLoaded', () => {
  tocbot.init({
    // Where to render the table of contents.
    tocSelector: '.toc__content',
    // Where to grab the headings to build the table of contents.
    contentSelector: '.article__content',
    // Which headings to grab inside of the contentSelector element.
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    // For headings inside relative or absolute positioned containers within content.
    hasInnerContainers: true,
    orderedList: false,
    collapseDepth: 2,
  });
})</script><link rel="preload" href="https://cdn.bootcss.com/highlight.js/9.6.0/styles/github.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.6.0/styles/github.min.css"><link rel="preload" href="https://fonts.googleapis.com/css?family=Abril+Fatface&amp;display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface&amp;display=swap"></head><body><div class="mask-border"></div><div class="head"><div class="head__inner"><h1><a href="/">张文轩</a></h1><p></p></div></div><div class="paper-container"><div class="main"><div class="location-bar"><div class="line-1"><div class="horizontal-line" style="height: 3px"></div></div><div class="line-2"><div class="horizontal-line" style="height: 1px"></div></div><p class="text">Objective-C中的内存管理</p><div class="switch-button"><input class="container_toggle" type="checkbox" id="switch" name="mode"><label for="switch">Toggle</label></div><div class="line-3"><div class="horizontal-line" style="height: 1px"></div></div></div><div class="main__2-col"><article class="post-view__article"><div class="article__infomation"><div class="posts-item"><h2 class="posts-item__title"><a href="">Objective-C中的内存管理</a></h2><span class="post__date">2019-10-20</span></div></div><div class="article__content"><h2 id="OC的内存分配机制"><a href="#OC的内存分配机制" class="headerlink" title="OC的内存分配机制"></a>OC的内存分配机制</h2><ul>
<li>OC中，对象通过alloc在堆上创建，一旦对象创建完成，就不能在再移动。</li>
</ul>
<h2 id="MRC和ARC"><a href="#MRC和ARC" class="headerlink" title="MRC和ARC"></a>MRC和ARC</h2><ul>
<li>OC中提供两种内存管理机制：MRC(Mannual Reference Counting)和ARC(Automatic Reference Counting)，指手动和自动管理，现在推荐使用ARC来管理内存。</li>
</ul>
<h2 id="MRC"><a href="#MRC" class="headerlink" title="MRC"></a>MRC</h2><table>
<thead>
<tr>
<th>对象操作</th>
<th style="text-align:center">OC中对应的方法</th>
<th style="text-align:center">对应的 retainCount 变化</th>
</tr>
</thead>
<tbody>
<tr>
<td>生成并持有对象</td>
<td style="text-align:center">alloc/new/copy/mutableCopy等</td>
<td style="text-align:center">+1</td>
</tr>
<tr>
<td>持有对象</td>
<td style="text-align:center">retain</td>
<td style="text-align:center">+1</td>
</tr>
<tr>
<td>释放对象</td>
<td style="text-align:center">release</td>
<td style="text-align:center">-1</td>
</tr>
<tr>
<td>废弃对象</td>
<td style="text-align:center">dealloc</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<h2 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h2><ul>
<li>ARC 是苹果引入的一种自动内存管理机制，会根据引用计数自动监视对象的生存周期，实现方式是在编译时期自动在已有代码中插入合适的内存管理代码以及在 Runtime 做一些优化。</li>
<li>在ARC中与内存管理有关的变量标识符，有下面几种：<ul>
<li><code>__strong</code></li>
<li><code>__weak</code></li>
<li><code>__unsafe_unretained</code></li>
<li><code>__autoreleasing</code></li>
</ul>
</li>
<li><code>__strong</code> 是默认使用的标识符。只有还有一个强指针指向某个对象，这个对象就会一直存活。</li>
<li><code>__weak</code> 声明这个引用不会保持被引用对象的存活，如果对象没有强引用了，弱引用会被置为 nil。</li>
<li><code>__unsafe_unretained</code> 声明这个引用不会保持被引用对象的存活，如果对象没有强引用了，它不会被置为 nil。如果它引用的对象被回收掉了，该指针就变成了野指针。</li>
<li><code>__autoreleasing</code> 用于标示使用引用传值的参数（id *），在函数返回时会被自动释放掉。</li>
<li>或者可以用属性标识符，前面的博客有提到</li>
</ul>
<h2 id="Autorelease-Pool"><a href="#Autorelease-Pool" class="headerlink" title="Autorelease Pool"></a>Autorelease Pool</h2><ul>
<li><p>在 ARC 下，我们并不需要手动调用 autorelease 有关的方法，甚至可以完全不知道 autorelease 的存在，就可以正确管理好内存。因为 Cocoa Touch 的 Runloop 中，每个 runloop circle 中系统都自动加入了 Autorelease Pool 的创建和释放。</p>
</li>
<li><p>当我们需要创建和销毁大量的对象时，使用手动创建的 autoreleasepool 可以有效的避免内存峰值的出现。因为如果不手动创建的话，外层系统创建的 pool 会在整个 runloop circle 结束之后才进行 drain，手动创建的话，会在 block 结束之后就进行 drain 操作。一个普遍被使用的例子如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSString</span>* string = <span class="string">@"ab c"</span>;</span><br><span class="line">        <span class="built_in">NSArray</span>* array = [string componentsSeparatedByString:string];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不使用 autoreleasepool ，需要在循环结束之后释放 100000000 个字符串，如果 使用的话，则会在每次循环结束的时候都进行 release 操作。</p>
</li>
</ul>
</div></article><div class="post-view__sidebar"><div class="sidebar"><div class="tocbot"><h2>Toc</h2><div class="toc__content"></div></div><h2>Archives</h2><div class="sidebar__archives"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">2018</a></li></ul></div><h2>Categories</h2><div class="sidebar__categories"></div><h2>Tags</h2><div class="sidebar__tags"><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mac/">Mac</a></li></ul></div></div></div></div><div class="horizontal-line" style="height: 1px"></div><div class="main__bottom"><div class="pre-next"><a class="pre-button" href="/2019/10/21/CocoaTouch中的事件处理/">CocoaTouch中的事件处理</a><a class="next-button" href="/2019/10/19/Objective-C中的Block/">Objective-C中的Block</a></div></div></div></div><div class="footer"><span>©️2019-2020 Designed By&nbsp;<strong><a href="https://github.com/random-yang">RandomYang</a></strong> Powered By&nbsp;</span><strong><a href="https://hexo.io">hexo</a></strong></div><div class="darkmode-mask" id="darkmode-mask"></div><div class="sidebar__button"></div></body></html>