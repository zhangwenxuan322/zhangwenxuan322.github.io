<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Friend</title>
    <link>http://yoursite.com/</link>
    
    <image>
      <url>http://yoursite.com/img/duck.png</url>
      <title>Friend</title>
      <link>http://yoursite.com/</link>
    </image>
    
    <atom:link href="http://yoursite.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Sun, 27 Sep 2020 02:19:14 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Man in the middle</title>
      <link>http://yoursite.com/2020/09/22/Man-in-the-middle/</link>
      <guid>http://yoursite.com/2020/09/22/Man-in-the-middle/</guid>
      <pubDate>Tue, 22 Sep 2020 13:15:34 GMT</pubDate>
      
      <description>&lt;p&gt;使用中间人攻击解密HTTPS流量&lt;br&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>使用中间人攻击解密HTTPS流量<br><a id="more"></a></p><h2 id="Mitm"><a href="#Mitm" class="headerlink" title="Mitm"></a>Mitm</h2><p>“中间人”在网络世界有独特的意义，他可以做好事也可以做坏事，但在本文只单纯的谈论技术本身。</p><blockquote><p><strong>中间人攻击</strong>（英语：<strong>M</strong>an-<strong>i</strong>n-<strong>t</strong>he-<strong>m</strong>iddle attack，缩写：<strong>MITM</strong>）在<a href="https://zh.wikipedia.org/wiki/密码学" target="_blank" rel="noopener">密码学</a>和<a href="https://zh.wikipedia.org/wiki/计算机安全" target="_blank" rel="noopener">计算机安全</a>领域中是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。在许多情况下这是很简单的（例如，在一个未加密的<a href="https://zh.wikipedia.org/wiki/Wi-Fi" target="_blank" rel="noopener">Wi-Fi</a> <a href="https://zh.wikipedia.org/wiki/无线接入点" target="_blank" rel="noopener">无线接入点</a>的接受范围内的中间人攻击者，可以将自己作为一个中间人插入这个网络）。</p></blockquote><h2 id="HTTP与HTTPS"><a href="#HTTP与HTTPS" class="headerlink" title="HTTP与HTTPS"></a>HTTP与HTTPS</h2><p>在谈论中间人攻击之前需要简单地讲解一下 HTTP 协议与 HTTPS 协议：</p><ol><li><p>HTTP 协议</p><p>Hyper Text Transfer Protocol，超文本传输协议。它基于 TCP/IP 通讯协议来传递数据，通过 TCP 请求，三次握手建立连接之后发送 HTTP 请求并接收 HTTP 响应。</p><p><img src="https://www.concurrency.com/getattachment/baa462c8-ac8e-49af-91ce-bc37e4234f31/http.png.aspx?lang=en-US" srcset="/img/loading.gif" alt="HTTP 协议的请求流程" title="HTTP 协议的请求流程"></p><p>它的请求报文和响应报文都由状态行、状态头以及正文组成：</p><p><img src="https://mdn.mozillademos.org/files/13687/HTTP_Request.png" srcset="/img/loading.gif" alt="报文" title="报文"></p><p>但 HTTP 协议存在信息明文传输的问题，这样可能导致请求内容被篡改、冒名顶替使用者等问题，通过抓包可以清楚的看到请求具体信息，存在安全隐患。</p><p><img src="https://portswigger.net/web-security/images/http-request-smuggling.svg" srcset="/img/loading.gif" alt="抓包" title="抓包"></p></li><li><p>HTTPS 协议</p><p>为了解决 HTTP 协议中存在的问题，HTTPS 横空出世。HTTPS = HTTP + SSL/TLS (HyperText Transfer Protocol over Secure Socket Layer)，借助 SSL 证书来验证服务器的身份，并且为浏览器和服务器之间的通信进行加密。</p><p><em>SSL(Secure Socket Layer，安全套接字层)</em>：1994年为 Netscape 所研发，SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。</p><p><em>TLS(Transport Layer Security，传输层安全)</em>：其前身是 SSL，它最初的几个版本（SSL 1.0、SSL 2.0、SSL 3.0）由网景公司开发，1999年从 3.1 开始被 IETF 标准化并改名，发展至今已经有 TLS 1.0、TLS 1.1、TLS 1.2 三个版本。SSL3.0和TLS1.0由于存在安全漏洞，已经很少被使用到。TLS 1.3 改动会比较大，目前还在草案阶段，目前使用最广泛的是TLS 1.1、TLS 1.2。</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/HTTPS_Process.png" srcset="/img/loading.gif" alt="HTTPS 协议流程" title="HTTPS流程"></p><ol><li>首先客户端通过URL访问服务器建立SSL连接。</li><li>服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端。</li><li>客户端的服务器开始协商SSL连接的安全等级，也就是信息加密的等级。</li><li>客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</li><li>服务器利用自己的私钥解密出会话密钥。</li><li>服务器利用会话密钥加密与客户端之间的通信。</li></ol><p>简而言之，就是用 HTTPS 协议的网站你没办法简单地抓包看到请求内容了。</p></li></ol><h2 id="拦截-HTTPS-请求内容"><a href="#拦截-HTTPS-请求内容" class="headerlink" title="拦截 HTTPS 请求内容"></a>拦截 HTTPS 请求内容</h2><p>由于 HTTPS 协议是用非对称加密算法，所以暴力解密几乎不可能。但即使这样安全的加解密流程下也存在漏洞，中间人劫持的流程如下：</p><ul><li>你和服务器之间有一台邪恶的路由器M</li><li>当你给HTTPS网站的服务器发请求后，网站带着公钥P响应你</li><li>响应到达M，M拿到了P，但是并不把它交给你，而是自己伪造了一对公私钥MP和MS，并把MP给你</li><li>你拿到MP，以为是网站的公钥P，用它加密了S，再请求网站</li><li>请求到达M，M使用MS解开S，再用P加密S交给网站</li></ul><p><img src="https://hackernoon.com/drafts/sh1g3wdt.png" srcset="/img/loading.gif" alt="MITM" title="MITM"></p><p>如果想在 Mac 上实践一下可以借助自带的 Keychain Access 软件生成一个被自己系统信任的 CA 证书，然后借助 Surge 等软件可以做到本机的 HTTPS 抓包。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB" target="_blank" rel="noopener">维基百科MITM</a></li><li><a href="http://scm.zoomquiet.top/data/20161106124704/index.html" target="_blank" rel="noopener">Surge MitM 证书的创建和配置</a></li><li><a href="https://zhuanlan.zhihu.com/p/72616216" target="_blank" rel="noopener">HTTP与HTTPS</a></li></ol>]]></content:encoded>
      
      
      
      <category domain="http://yoursite.com/tags/Internet/">Internet</category>
      
      
      <comments>http://yoursite.com/2020/09/22/Man-in-the-middle/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>如何突破macOS的文件安全权限限制</title>
      <link>http://yoursite.com/2020/09/10/%E5%A6%82%E4%BD%95%E7%AA%81%E7%A0%B4macOS%E7%9A%84%E6%96%87%E4%BB%B6%E5%AE%89%E5%85%A8%E6%9D%83%E9%99%90%E9%99%90%E5%88%B6/</link>
      <guid>http://yoursite.com/2020/09/10/%E5%A6%82%E4%BD%95%E7%AA%81%E7%A0%B4macOS%E7%9A%84%E6%96%87%E4%BB%B6%E5%AE%89%E5%85%A8%E6%9D%83%E9%99%90%E9%99%90%E5%88%B6/</guid>
      <pubDate>Thu, 10 Sep 2020 06:59:55 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;今天在尝试用Python连接Oracle数据库时遇到一个报错：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs undefined&quot;&gt;cx_Oracle.DatabaseError: DPI-1047: Cannot locate a 64-bit Oracle&lt;sp</description>
        
      
      
      
      <content:encoded><![CDATA[<p>今天在尝试用Python连接Oracle数据库时遇到一个报错：</p><pre><code class="hljs undefined">cx_Oracle.DatabaseError: DPI-1047: Cannot locate a 64-bit Oracle<span class="hljs-built_in"> Client </span>library: <span class="hljs-string">"dlopen(libclntsh.dylib, 1): no suitable image found.</span></code></pre><p>大致是需要一个64位的Oracle客户端，而我的Mac上没有，那么解决方案也很简单，去下一个就好，为了轻便选择了Instant Oracle（instantclient-basiclite-macos.x64-19.3.0.0.0dbru.zip）<a href="https://www.oracle.com/database/technologies/instant-client/macos-intel-x86-downloads.html" target="_blank" rel="noopener">下载地址</a>。然后遵循如下操作即可完成轻量Oracle客户端的安装：</p><ol><li><p>创建文件夹，并将压缩包解压到这个文件夹下</p><pre><code class="hljs undefined">sudo mkdir -p /opt/oraclesudp cp instantclient-basic-macos.x64<span class="hljs-number">-19.3</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>dbru.zip /opt/oracle/（如果当前在下载文件所在目录下）cd /opt/oracle/sudo unzip instantclient-basic-macos.x64<span class="hljs-number">-19.3</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>dbru.zip</code></pre></li><li><p>创建超链接，以使应用程序能够找到该库</p><pre><code class="hljs undefined">mkdir ~<span class="hljs-regexp">/libln -s /opt</span><span class="hljs-regexp">/oracle/instantclient</span>_19_3/libclntsh.dylib ~<span class="hljs-regexp">/lib/</span></code></pre></li></ol><p>到此应该再执行Python的数据读取程序就可以成功了，但是他出现了：（当时没截图，从网上找的，版本号不太对但不影响）</p><p><img src="/2020/09/10/如何突破macOS的文件安全权限限制/security.png" srcset="/img/loading.gif" alt="security"></p><p>这也没吓住我，去系统设置的安全项里给他解封了就好，但是我解封之后仍然遇到同样的错误，这就一时摸不着头脑了。</p><p>Google了一番，发现<a href="http://oraontap.blogspot.com/2020/01/mac-os-x-catalina-and-oracle-instant.html" target="_blank" rel="noopener">这篇文章</a>，通过<code>ls -lg@</code>命令，我们可以得到以下：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ls -lg@</span>total 484136-r-xr-xr-x@ 1 staff       5780 Feb 22  2019 BASIC_LICENSE com.apple.quarantine        57 -rw-r--r--@ 1 staff       1670 Aug 19 05:57 BASIC_README com.apple.quarantine        57 -r-xr-xr-x@ 1 staff       5780 Feb 22  2019 SQLPLUS_LICENSE com.apple.quarantine        57 -rw-r--r--@ 1 staff       1676 Sep  6 04:11 SQLPLUS_README com.apple.quarantine        57 -rwxr-xr-x@ 1 staff       9888 Aug 19 05:57 adrci com.apple.quarantine        57 -rwxr-xr-x@ 1 staff      40368 Aug 19 05:57 genezi com.apple.quarantine        57 -r-xr-xr-x@ 1 staff        342 Apr 24  2015 glogin.sql com.apple.quarantine        57 lrwxrwxrwx  1 staff         20 Jan 16 08:39 libclntsh.dylib -&gt; libclntsh.dylib.19.1lrwxrwxrwx  1 staff         20 Jan 16 08:39 libclntsh.dylib.10.1 -&gt; libclntsh.dylib.19.1lrwxrwxrwx  1 staff         20 Jan 16 08:39 libclntsh.dylib.11.1 -&gt; libclntsh.dylib.19.1lrwxrwxrwx  1 staff         20 Jan 16 08:39 libclntsh.dylib.12.1 -&gt; libclntsh.dylib.19.1lrwxrwxrwx  1 staff         20 Jan 16 08:39 libclntsh.dylib.18.1 -&gt; libclntsh.dylib.19.1-rwxr-xr-x@ 1 staff   98137256 Aug 13 02:10 libclntsh.dylib.19.1 com.apple.quarantine        57 -rwxr-xr-x@ 1 staff    4803832 Jul  7  2019 libclntshcore.dylib.19.1 com.apple.quarantine        57 -rwxr-xr-x@ 1 staff    8349944 Aug  6 12:14 libnnz19.dylib com.apple.quarantine        57 lrwxrwxrwx  1 staff         18 Jan 16 08:39 libocci.dylib -&gt; libocci.dylib.19.1lrwxrwxrwx  1 staff         18 Jan 16 08:39 libocci.dylib.10.1 -&gt; libocci.dylib.19.1lrwxrwxrwx  1 staff         18 Jan 16 08:39 libocci.dylib.11.1 -&gt; libocci.dylib.19.1lrwxrwxrwx  1 staff         18 Jan 16 08:39 libocci.dylib.12.1 -&gt; libocci.dylib.19.1lrwxrwxrwx  1 staff         18 Jan 16 08:39 libocci.dylib.18.1 -&gt; libocci.dylib.19.1-rwxr-xr-x@ 1 staff    1594048 Jul  5  2019 libocci.dylib.19.1 com.apple.quarantine        57 -rwxr-xr-x@ 1 staff  125518764 Aug 19 05:57 libociei.dylib com.apple.quarantine        57 -r-xr-xr-x@ 1 staff     151980 Jul  3  2019 libocijdbc19.dylib com.apple.quarantine        57 -rwxr-xr-x@ 1 staff     100492 Aug 13 02:32 liboramysql19.dylib com.apple.quarantine        57 -rwxrwxrwx@ 1 staff    1322588 Sep  6 04:05 libsqlplus.dylib com.apple.quarantine        57 -r-xr-xr-x@ 1 staff    1659868 Jul  5  2019 libsqlplusic.dylib com.apple.quarantine        57 drwxr-xr-x@ 3 staff         96 Aug 19 05:57 network com.apple.quarantine        57 -rw-r--r--@ 1 staff    4210510 May 10  2019 ojdbc8.jar com.apple.quarantine        57 -rwxr-xr-x@ 1 staff       8528 Sep  6 04:11 sqlplus com.apple.quarantine        57 -rw-r--r--@ 1 staff    1680080 May 10  2019 ucp.jar com.apple.quarantine        57 -rwxr-xr-x@ 1 staff     150080 Aug 19 05:57 uidrvci com.apple.quarantine        57 -rw-r--r--@ 1 staff      74263 Apr 16  2019 xstreams.jar com.apple.quarantine        57</code></pre><p>这里不难看出macOS通过文件上的<code>com.apple.quarantine</code>标签来判断该文件是否应该被过滤，简单的解决方法就是把这些标签删掉，<em>注意！！：执行以下操作前请务必判断程序无问题，不然会给Mac带来感染病毒的风险</em></p><ol><li><p>先给所有文件写权限，因为有些文件没有该权限：</p><pre><code class="hljs undefined"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> instantclient_19_3</span><span class="hljs-meta">$</span><span class="bash"> sudo chmod u+w *</span></code></pre></li><li><p>删除<code>com.apple.quarantine</code>标签：</p><pre><code class="hljs undefined"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> ..</span><span class="hljs-meta">$</span><span class="bash"> xattr -r -d -s com.apple.quarantine instantclient_19_3</span></code></pre></li></ol><p>这只是一种应用场景，实际上可以应用在更多被隔离的<strong>安全软件</strong>上，使用之前请先权衡，安全第一位。</p>]]></content:encoded>
      
      
      
      <category domain="http://yoursite.com/tags/Mac/">Mac</category>
      
      
      <comments>http://yoursite.com/2020/09/10/%E5%A6%82%E4%BD%95%E7%AA%81%E7%A0%B4macOS%E7%9A%84%E6%96%87%E4%BB%B6%E5%AE%89%E5%85%A8%E6%9D%83%E9%99%90%E9%99%90%E5%88%B6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>vim搭建python环境</title>
      <link>http://yoursite.com/2020/09/08/vim%E6%90%AD%E5%BB%BApython%E7%8E%AF%E5%A2%83/</link>
      <guid>http://yoursite.com/2020/09/08/vim%E6%90%AD%E5%BB%BApython%E7%8E%AF%E5%A2%83/</guid>
      <pubDate>Tue, 08 Sep 2020 12:48:40 GMT</pubDate>
      
        
        
      <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Vim和Python3&lt;/p&gt;
&lt;p&gt;如果用的是macOS，并且是系统自带的Vim，那么它默认是不支持Python3的，可以通过&lt;code&gt;vim --version | grep python&lt;/code&gt;查看。&lt;/p&gt;
&lt;p&gt;那么首先就是要安装一个支持</description>
        
      
      
      
      <content:encoded><![CDATA[<ul><li><p>Vim和Python3</p><p>如果用的是macOS，并且是系统自带的Vim，那么它默认是不支持Python3的，可以通过<code>vim --version | grep python</code>查看。</p><p>那么首先就是要安装一个支持Python3的Vim，这里brew提供了支持，通过brew安装的Vim默认支持Python3，安装语句<code>brew install vim</code>。同时Mac自带的是Python2，所以还需要安装Python3，安装语句<code>brew install python3</code>。为了能让系统调用到我们后来通过brew安装的Vim和Python3，需要修改系统环境变量加载顺序:</p><ol><li><code>sudo vim /etc/paths</code></li><li>调整顺序，将<code>/usr/local/bin</code>调至第一顺位</li><li>重启终端</li><li>完成上述操作后即可用which命令查看调用的vim和python3来源。</li></ol></li><li><p>Mac上Vim中内容复制到其他程序</p><p>在.vimrc中配置：<code>set clipboard=unnamed</code></p></li><li><p>Vim中直接运行Python文件</p><p>在.vimrc中配置如下内容：</p><pre><code class="hljs sh"><span class="hljs-string">" Python相关filetype plugin on"</span> 按 F5 执行当前 Python 代码<span class="hljs-string">"map &lt;F5&gt; :call PRUN()&lt;CR&gt;func! PRUN()    exec "</span>w<span class="hljs-string">"    if &amp;filetype == 'python'        exec "</span>!python3 %<span class="hljs-string">"    endifendfunc</span></code></pre></li><li><p>Vim插件</p><p>推荐使用vim-plug进行Vim的插件管理，安装步骤如下：</p><pre><code class="hljs shell">mkdir ~/.vim/autoload/cd ~/.vim/autoload/wget https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</code></pre><p><a href="https://raw.githubusercontent.com的域名被DNS污染了，被解析成无效IP，需要挂代理。" target="_blank" rel="noopener">https://raw.githubusercontent.com的域名被DNS污染了，被解析成无效IP，需要挂代理。</a></p><p>安装完成后只需要在.vimrc中将插件写在如下代码块中：</p><pre><code class="hljs sh">call plug<span class="hljs-comment">#begin('~/.vim/plugged')</span><span class="hljs-string">"插件写在这里"</span><span class="hljs-string">"Plug 'xxx/xxx' 格式像这样"</span> call plug<span class="hljs-comment">#end()</span></code></pre><p>保存后执行<code>:PlugInstall</code>即可自动安装插件</p></li><li><p>关于jedi-vim插件无法联想第三方库文件的问题</p><p>这个问题真是困扰了我一个下午，查找了很多资料，本来以为是macOS的问题，结果看到官方的一个<a href="https://github.com/davidhalter/jedi/issues/1188" target="_blank" rel="noopener">issue</a>上面提到jedi-vim还不支持Python3.7的第三方库查询，但是这个issue是两年前提出的并且作者说会在4-5个月内完成，不知道为什么还不支持：）。不过如果按照我上面的操作是不会遇到这个问题的，因为brew默认安装Python3.8，我之前用的是Python3.7。</p></li><li><p>其他的好用插件</p><ol><li>indentLine：<code>Plug &#39;Yggdroot/indentLine&#39;</code>缩进指示器，<code>:IndentLinesToggle</code>开启或关闭</li><li>autopep8：<code>Plug &#39;tell-k/vim-autopep8&#39;</code>代码格式化，<code>:Autopep8</code>运行</li><li>vim-flake8：<code>pip3 install flake8</code> -&gt; <code>Plug &#39;nvie/vim-flake8&#39;</code>代码检查，F7调用</li><li>auto-pairs：<code>Plug &#39;jiangmiao/auto-pairs&#39;</code>自动补齐括号</li><li>nerdcommenter：<code>Plug &#39;preservim/nerdcommenter&#39;</code>快捷注释，<code>\cc</code>注释，<code>\cu</code>反注释，前面可以加行数，默认是一行</li></ol></li></ul><h3 id="Vim光标操作"><a href="#Vim光标操作" class="headerlink" title="Vim光标操作"></a>Vim光标操作</h3><p>这里再列举一些常用的光标快捷操作，加以练习就能烂熟于心：</p><ul><li>w 向前移动一个单词，b 向后移动一个单词，e 移动到下一个单词的词尾，ge 移动到上一个单词的词尾</li><li>gg 移动到文件头，G 移动到文件尾，$ 移动到行头，^ 移动到行尾</li><li>y 复制指定范围内的内容，如要复制全文：ggyG</li><li>:行数，可前往指定行</li><li>dw 从指定位置删到下个单词开头，daw 删除光标所在的单词，dd 删除整行</li><li>u 撤销操作，在.vimrc中配置<code>nnoremap U &lt;C-r&gt;</code>可得到 U 反撤销的操作</li></ul>]]></content:encoded>
      
      
      
      
      <comments>http://yoursite.com/2020/09/08/vim%E6%90%AD%E5%BB%BApython%E7%8E%AF%E5%A2%83/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>git commit提交关键字整理</title>
      <link>http://yoursite.com/2020/08/17/git-commit%E6%8F%90%E4%BA%A4%E5%85%B3%E9%94%AE%E5%AD%97%E6%95%B4%E7%90%86/</link>
      <guid>http://yoursite.com/2020/08/17/git-commit%E6%8F%90%E4%BA%A4%E5%85%B3%E9%94%AE%E5%AD%97%E6%95%B4%E7%90%86/</guid>
      <pubDate>Mon, 17 Aug 2020 07:06:46 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;看到了阿里技术微信公众号的关于&lt;code&gt;git commit&lt;/code&gt;规范的建议文章，在此做一下个人习惯上的整理&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;团队开</description>
        
      
      
      
      <content:encoded><![CDATA[<p>看到了阿里技术微信公众号的关于<code>git commit</code>规范的建议文章，在此做一下个人习惯上的整理</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>团队开发中，富有个性的提交信息往往会引起同事们的理解困难，更不要说中英混杂、缩写、笼统概括等问题。个人观点：中文团队中提交信息以中文为主，除非专业术语等不便于翻译的词汇用英文；大家都能接受的缩写可以写，避免独创缩写；信息要写详细，如修复了某一问题不要单纯的写<code>fix bug</code>这样模棱两可的文字，要具体到问题。</p><h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><p>按照阿里技术的介绍，提交信息的格式应该如下：</p><p><code>&lt;type&gt;(&lt;scope&gt;):&lt;subject&gt;</code></p><ul><li><p>type(必须)</p><p>提交类别，包含以下几种类型：</p><ol><li>feat: 新功能的添加，feature的前四个字母；</li><li>fix/to: 修复bug（fix:最终完成时使用，to:修复过程中的多次提交使用）</li><li>docs: 文档</li><li>style: 格式，不影响代码运行的变动</li><li>refactor: 重构</li><li>perf: 优化</li><li>test: 测试</li><li>chore: 辅助工具的开发</li><li>revert: 回滚版本</li><li>merge: 代码合并</li><li>sync: 同步主线或分支</li></ol></li><li><p>scope(可选)</p><p>变动影响的范围，根据架构方式不同而不同。</p></li><li><p>subject(必须)</p><p>对于提交的描述，不超过50个字符，根据团队选择语言，句尾不加标点。</p></li></ul><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><pre><code class="hljs undefined"><span class="hljs-function"><span class="hljs-title">refactor</span><span class="hljs-params">(Converter)</span></span>:重构聚合操作<span class="hljs-function"><span class="hljs-title">docs</span><span class="hljs-params">(README)</span></span>:添加README文档</code></pre><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>规范的提交信息便于项目历史追溯，可以格式化提交信息进行日志分析。</p>]]></content:encoded>
      
      
      
      
      <comments>http://yoursite.com/2020/08/17/git-commit%E6%8F%90%E4%BA%A4%E5%85%B3%E9%94%AE%E5%AD%97%E6%95%B4%E7%90%86/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>个人配置记录</title>
      <link>http://yoursite.com/2020/05/29/%E4%B8%AA%E4%BA%BA%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/</link>
      <guid>http://yoursite.com/2020/05/29/%E4%B8%AA%E4%BA%BA%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/</guid>
      <pubDate>Fri, 29 May 2020 07:58:20 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;zshrc&quot;&gt;&lt;a href=&quot;#zshrc&quot; class=&quot;headerlink&quot; title=&quot;.zshrc&quot;&gt;&lt;/a&gt;.zshrc&lt;/h1&gt;&lt;pre&gt;&lt;code class=&quot;hljs shell&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;/sp</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="zshrc"><a href="#zshrc" class="headerlink" title=".zshrc"></a>.zshrc</h1><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$HOME</span>/bin:/usr/<span class="hljs-built_in">local</span>/bin:<span class="hljs-variable">$PATH</span></span>export ZSH="/Users/zhangwenxuan/.oh-my-zsh"export LANG=en_US.UTF-8ZSH_THEME="lambda"DISABLE_AUTO_UPDATE="true"plugins=(git extract safe-paste colored-man-pages autojump)source $ZSH/oh-my-zsh.sh<span class="hljs-meta">#</span><span class="bash"> Maven</span>export M2_HOME=/Users/zhangwenxuan/apache-maven-3.3.9export PATH=$PATH:$M2_HOME/bin<span class="hljs-meta">#</span><span class="bash"> redis命令</span><span class="hljs-meta">#</span><span class="bash"> 开启服务:redis-server /usr/<span class="hljs-built_in">local</span>/etc/redis.conf</span>alias rd-st="redis-server /usr/local/etc/redis.conf"<span class="hljs-meta">#</span><span class="bash"> 开启客户端:redis-cli --raw (支持中文转义)</span><span class="hljs-meta">#</span><span class="bash"> 关闭服务:在客户端中shutdown</span><span class="hljs-meta">#</span><span class="bash"> flowchar</span>alias flowchar="~/Documents/FlowChar/build/flowcharo"<span class="hljs-meta">#</span><span class="bash"> 个人别名配置</span>alias la="ls -alh"alias py="python3"alias pi="python3 -m pip"alias v="vim"alias cl="clear"<span class="hljs-meta">#</span><span class="bash"> PATH</span>export PATH="/usr/local/mysql/bin:$PATH"test -e "$&#123;HOME&#125;/.iterm2_shell_integration.zsh" &amp;&amp; source "$&#123;HOME&#125;/.iterm2_shell_integration.zsh"</code></pre><h1 id="vimrc"><a href="#vimrc" class="headerlink" title=".vimrc"></a>.vimrc</h1><pre><code class="hljs shell">" Configuration file for vimset modelines=0" CVE-2007-2438set backspace=2" more powerful backspacing" Don't write backup file if vim is being called by "crontab -e"au BufWrite /private/tmp/crontab.* set nowritebackup nobackup" Don't write backup file if vim is being called by "chpass"au BufWrite /private/etc/pw.* set nowritebackup nobackuplet skip_defaults_vim=1" 开启语法高亮syntax onset nocompatible" 缩进长度set shiftwidth=4" 退回缩进长度set softtabstop=4set nu!" 提示当前模式set showmode" 开启鼠标操作set mouse=a" 开启256色set t_Co=256" 开启自动缩进" set autoindent" 光标所在行高亮set cursorline" 不会在单词内折行set wrap" 垂直滚动光标距离底部的距离set scrolloff=15" 显示光标当前位置set ruler" 自动匹配括号set showmatch" 搜索时高亮提示set hlsearch" 搜索时每输入一个字母就回到第一个匹配内容set incsearch" 搜索时忽略大小写set ignorecase" 开启文件监视set autoread" 设置Vim窗口标题set title" vim中内容可以复制到其他程序set clipboard=unnamed" Python相关filetype plugin on" 按 F5 执行当前 Python 代码"map &lt;F5&gt; :call PRUN()&lt;CR&gt;func! PRUN()    exec "w"    if &amp;filetype == 'python'        exec "!python3 %"    endifendfunc" 快捷键映射" 以下为Vim的常用操作简化" 取消撤销操作nnoremap U &lt;C-r&gt;" 插件管理call plug#begin('~/.vim/plugged')Plug 'davidhalter/jedi-vim'Plug 'Yggdroot/indentLine'Plug 'tell-k/vim-autopep8'Plug 'nvie/vim-flake8'Plug 'jiangmiao/auto-pairs'Plug 'preservim/nerdcommenter'Plug 'vimwiki/vimwiki'Plug 'preservim/nerdtree'call plug#end()let g:jedi#completions_command = "&lt;C-N&gt;"</code></pre><h1 id="etc-motd"><a href="#etc-motd" class="headerlink" title="/etc/motd"></a>/etc/motd</h1><p>进入终端的提示文字，修改需要sudo</p><pre><code class="hljs undefined">You have <span class="hljs-keyword">no</span> responsibility <span class="hljs-keyword">to</span> live <span class="hljs-keyword">up</span> <span class="hljs-keyword">to</span> what other people think you ought <span class="hljs-keyword">to</span> accomplish. I have <span class="hljs-keyword">no</span> responsibility <span class="hljs-keyword">to</span> <span class="hljs-keyword">be</span> like they expect <span class="hljs-keyword">me</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">be</span>. It<span class="hljs-string">'s their mistake, not my failing.</span></code></pre>]]></content:encoded>
      
      
      
      
      <comments>http://yoursite.com/2020/05/29/%E4%B8%AA%E4%BA%BA%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>大数据历史发展以及未来架构路线</title>
      <link>http://yoursite.com/2020/05/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%8E%86%E5%8F%B2%E5%8F%91%E5%B1%95%E4%BB%A5%E5%8F%8A%E6%9C%AA%E6%9D%A5%E6%9E%B6%E6%9E%84%E8%B7%AF%E7%BA%BF/</link>
      <guid>http://yoursite.com/2020/05/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%8E%86%E5%8F%B2%E5%8F%91%E5%B1%95%E4%BB%A5%E5%8F%8A%E6%9C%AA%E6%9D%A5%E6%9E%B6%E6%9E%84%E8%B7%AF%E7%BA%BF/</guid>
      <pubDate>Fri, 29 May 2020 01:31:20 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;大数据历史&quot;&gt;&lt;a href=&quot;#大数据历史&quot; class=&quot;headerlink&quot; title=&quot;大数据历史&quot;&gt;&lt;/a&gt;大数据历史&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;2004年&lt;/p&gt;
&lt;p&gt;Google的三篇论文为大数据发展打下基础，这三篇论文分别为：&lt;/p&gt;
</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="大数据历史"><a href="#大数据历史" class="headerlink" title="大数据历史"></a>大数据历史</h1><ul><li><p>2004年</p><p>Google的三篇论文为大数据发展打下基础，这三篇论文分别为：</p><ol><li>分布式文件系统GFS</li><li>大数据分布式计算框架MapReduce</li><li>NoSQL类型数据库BigTable</li></ol></li><li><p>2006年</p><p>Doug Cutting启动了一个赫赫有名的项目：Hadoop，主要包括Hadoop分布式文件系统HDFS和大数据计算引擎MapReduce，分别实现了GFS和MapReduce其中两篇论文</p></li><li><p>2007年</p><p>HBase诞生，实现了三篇论文中的最后一篇BigTable</p></li><li><p>2008年</p><p>出现了Pig、Hive等支持使用SQL语法来进行大数据计算，极大的降低了Hadoop的使用难度，数据分析师和工程师可以无门槛的对大数据进行数据分析和处理</p></li><li><p>2012年</p><p>Hadoop将执行引擎和资源调度分离出来，成立了Yarn资源调度系统，这年Spark也开始崭露头角，逐步替代MapReduce在企业应用中的地位</p></li></ul><h1 id="大数据架构"><a href="#大数据架构" class="headerlink" title="大数据架构"></a>大数据架构</h1><p>首先需要明确的是什么样的项目需要使用到大数据解决方案。如果数据只是GB级的项目，数据源单一的项目，并没有必要使用大数据解决方案。只有数据量达到TB或者PB并且数据有持续大量增加的可能性并且有多个数据源的情况下，才有必要使用大数据。</p><center class="half"><br><img src="/2020/05/29/大数据历史发展以及未来架构路线/Big Data Archtecture.png" srcset="/img/loading.gif"><br></center><p>上图简单划分了大数据的架构设计，主要分为以下几层：</p><ol><li><p>数据来源层(Sources Layer)</p><p>该架构的设计在很大程度上取决于数据源。这些数据是从许多不同格式的数据来源获取的，这些来源包括关系型数据库，企业服务器和传感器，如物联网设备，第三方数据提供商等，这些数据既可以是批量数据也可以是实时数据。</p></li><li><p>数据注入层(Data Ingestion Layer)</p><p>这是大数据开始旅程的第一层。该层将数据进行归类整理并传输给之后的层次。一般来说，这一层的数据可以通过像Kafka这样的消息队列或者是通过REST Api的形式进行传递。</p></li><li><p>存储层(Storage Layer)</p><p>这一层是大数据的接收端，它用在最合适的方式接收各种数据源，并将其存储。该层甚至可以根据系统的要求改变数据的格式。例如，批处理数据通常存储在分布式文件存储系统诸如HDFS等，在另一方面，结构化数据只能使用RDBMS来存储，这一切都取决于数据的格式。</p></li><li><p>分析层(Analysis Layer)</p><p>采用大数据的公司的唯一目标就是从数据中获得洞察力，从而进行数据驱动的决策。为了使用户分析大数据，在大数据架构中最重要的一层是分析层。这层与存储层交互，该架构需要多种工具来分析大数据。结构化数据是很容易处理的，而分析非结构化数据需要进行一些先进的工具。</p></li><li><p>批处理(Batch Processing)</p><p>由于数据量非常大，该架构需要一个批式处理系统去过滤、聚合以及处理数据以便于高级分析。这些都是长期运行的批处理作业，涉及到从存储层读取数据、处理、最后写入输出到新文件，批处理目前主要采用Spark来解决。</p></li><li><p>流处理(Real-Time Processing)</p><p>处理实时数据是在大数据世界里最热的潮流。流处理需要有一个系统来捕捉和存储实时数据，目前最好的解决方案是Flink，并且在未来Flink有代替Spark做批处理作业的趋势。</p></li><li><p>商业分析层(BI Layer)</p><p>这一层对接收到的最终数据进行分析，主要由人来进行决策。</p></li></ol><h1 id="大数据未来发展"><a href="#大数据未来发展" class="headerlink" title="大数据未来发展"></a>大数据未来发展</h1><p>大数据发展的十多年来，数据一直呈现成倍上涨并且没有放缓的趋势。这些数据的聚集主要是通过互联网，包括社交网络，网页搜索请求，文本消息和媒体文件。数据的另一巨大份额是通过物联网装置和传感器获取的。这些数据的大量增长带动了经济发展，根据Statista的调查，这部分经济增长已经达到了490亿美元。</p><p>对于未来大数据方向有以下预测：</p><ol><li>数据量将继续增加，并且数据将向云迁移</li><li>机器学习将会在大数据领域中越来越重要</li><li>数据科学家将在高需求</li><li>隐私仍将是一个热点问题</li><li>流处理将占据主导地位</li></ol><p>就我所在的公司而言，目前也有将大数据批处理引擎从Spark迁移到Flink的趋势，Flink发展迅速，在短时间内就成为了Apache基金会下的顶级项目，再加上背后有大公司对开源社区的支持，Flink无疑是未来更好的选择。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><p>大数据历史</p><p><a href="https://www.cnblogs.com/chenqionghe/p/11375295.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenqionghe/p/11375295.html</a></p></li><li><p>大数据架构</p><p><a href="https://towardsdatascience.com/big-data-architecture-the-art-of-handling-big-data-bc565c3a7295" target="_blank" rel="noopener">https://towardsdatascience.com/big-data-architecture-the-art-of-handling-big-data-bc565c3a7295</a></p></li><li><p>大数据未来发展</p><p><a href="https://www.itransition.com/blog/the-future-of-big-data" target="_blank" rel="noopener">https://www.itransition.com/blog/the-future-of-big-data</a></p></li></ul>]]></content:encoded>
      
      
      
      
      <comments>http://yoursite.com/2020/05/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%8E%86%E5%8F%B2%E5%8F%91%E5%B1%95%E4%BB%A5%E5%8F%8A%E6%9C%AA%E6%9D%A5%E6%9E%B6%E6%9E%84%E8%B7%AF%E7%BA%BF/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>项目打包到阿里云运行并停止的流程</title>
      <link>http://yoursite.com/2020/05/20/%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91%E8%BF%90%E8%A1%8C%E5%B9%B6%E5%81%9C%E6%AD%A2%E7%9A%84%E6%B5%81%E7%A8%8B/</link>
      <guid>http://yoursite.com/2020/05/20/%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91%E8%BF%90%E8%A1%8C%E5%B9%B6%E5%81%9C%E6%AD%A2%E7%9A%84%E6%B5%81%E7%A8%8B/</guid>
      <pubDate>Wed, 20 May 2020 01:45:11 GMT</pubDate>
      
        
        
      <description>&lt;center class=&quot;half&quot;&gt;&lt;br&gt;&lt;img src=&quot;/2020/05/20/项目打包到阿里云运行并停止的流程/项目打包到阿里云运行并停止的流程.png&quot; srcset=&quot;/img/loading.gif&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;h2 id=&quot;附上数据科</description>
        
      
      
      
      <content:encoded><![CDATA[<center class="half"><br><img src="/2020/05/20/项目打包到阿里云运行并停止的流程/项目打包到阿里云运行并停止的流程.png" srcset="/img/loading.gif"><br></center><h2 id="附上数据科学地铁线路图"><a href="#附上数据科学地铁线路图" class="headerlink" title="附上数据科学地铁线路图"></a>附上数据科学地铁线路图</h2><center class="half"><br><img src="/2020/05/20/项目打包到阿里云运行并停止的流程/metro.jpg" srcset="/img/loading.gif"><br></center>]]></content:encoded>
      
      
      
      
      <comments>http://yoursite.com/2020/05/20/%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91%E8%BF%90%E8%A1%8C%E5%B9%B6%E5%81%9C%E6%AD%A2%E7%9A%84%E6%B5%81%E7%A8%8B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spark中的TSUDAF</title>
      <link>http://yoursite.com/2020/04/02/Spark%E4%B8%AD%E7%9A%84TSUDAF/</link>
      <guid>http://yoursite.com/2020/04/02/Spark%E4%B8%AD%E7%9A%84TSUDAF/</guid>
      <pubDate>Thu, 02 Apr 2020 02:41:53 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;类型安全的用户自定义聚合函数（Type-Safe-User-Defined-Aggregate-Functions）&quot;&gt;&lt;a href=&quot;#类型安全的用户自定义聚合函数（Type-Safe-User-Defined-Aggregate-Functions）&quot; cl</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="类型安全的用户自定义聚合函数（Type-Safe-User-Defined-Aggregate-Functions）"><a href="#类型安全的用户自定义聚合函数（Type-Safe-User-Defined-Aggregate-Functions）" class="headerlink" title="类型安全的用户自定义聚合函数（Type-Safe User-Defined Aggregate Functions）"></a>类型安全的用户自定义聚合函数（Type-Safe User-Defined Aggregate Functions）</h1><h2 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h2><p>Itemdata.data</p><pre><code class="hljs undefined"><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">11</span>,<span class="hljs-number">4.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">32</span>,<span class="hljs-number">1.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">176</span>,<span class="hljs-number">27.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">183</span>,<span class="hljs-number">11.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">184</span>,<span class="hljs-number">5.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">207</span>,<span class="hljs-number">9.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">256</span>,<span class="hljs-number">3.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">258</span>,<span class="hljs-number">4.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">259</span>,<span class="hljs-number">16.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">260</span>,<span class="hljs-number">8.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">261</span>,<span class="hljs-number">18.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">301</span>,<span class="hljs-number">1.0</span></code></pre><p>实现类型安全的用户自定义聚合函数需要集成org.apache.spark.sql.expressions.Aggregator的Aggregator[K,V,C]抽象类，并且实现该类的6个函数。</p><h2 id="zero"><a href="#zero" class="headerlink" title="zero"></a>zero</h2><p>zero相当于UDAF中的initialize初始化函数，初始化存储中间数据的Average</p><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><p>reduce函数相当于UDAF中的update函数，当有新的数据a时，更新中间数据b。</p><h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><p>同UDAF中的merge</p><h2 id="finish"><a href="#finish" class="headerlink" title="finish"></a>finish</h2><p>同UDAF中的evaluate</p><h2 id="bufferEncoder"><a href="#bufferEncoder" class="headerlink" title="bufferEncoder"></a>bufferEncoder</h2><p>缓冲数据编码方式</p><h2 id="outputEncoder"><a href="#outputEncoder" class="headerlink" title="outputEncoder"></a>outputEncoder</h2><p>结果数据输出的编码方式</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><pre><code class="hljs scala"><span class="hljs-keyword">import</span> org.apache.spark.sql.&#123;<span class="hljs-type">Encoder</span>, <span class="hljs-type">Encoders</span>, <span class="hljs-type">SparkSession</span>&#125;<span class="hljs-keyword">import</span> org.apache.spark.sql.expressions.<span class="hljs-type">Aggregator</span><span class="hljs-comment">/** * 类型安全的自定义算子聚合测试类 */</span><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">TSUDAFTest</span> </span>&#123;  <span class="hljs-comment">// 映射数据</span>  <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Data</span>(<span class="hljs-params">user_id: <span class="hljs-type">String</span>, item_id: <span class="hljs-type">String</span>, score: <span class="hljs-type">Double</span></span>)</span>  <span class="hljs-comment">// 注意声明为var，因为要进行计算</span>  <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Average</span>(<span class="hljs-params">var sum: <span class="hljs-type">Double</span>, var count: <span class="hljs-type">Long</span></span>)</span>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTSUDAF</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Aggregator</span>[<span class="hljs-type">Data</span>, <span class="hljs-type">Average</span>, <span class="hljs-type">Double</span>] </span>&#123;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">zero</span></span>: <span class="hljs-type">Average</span> = <span class="hljs-type">Average</span>(<span class="hljs-number">0.0</span>D, <span class="hljs-number">0</span>L)    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reduce</span></span>(b: <span class="hljs-type">Average</span>, a: <span class="hljs-type">Data</span>): <span class="hljs-type">Average</span> = &#123;      b.sum += a.score      b.count += <span class="hljs-number">1</span>L      b    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge</span></span>(b1: <span class="hljs-type">Average</span>, b2: <span class="hljs-type">Average</span>): <span class="hljs-type">Average</span> = &#123;      b1.sum += b2.sum      b1.count += b2.count      b1    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">finish</span></span>(reduction: <span class="hljs-type">Average</span>): <span class="hljs-type">Double</span> = reduction.sum / reduction.count    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bufferEncoder</span></span>: <span class="hljs-type">Encoder</span>[<span class="hljs-type">Average</span>] = <span class="hljs-type">Encoders</span>.product    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">outputEncoder</span></span>: <span class="hljs-type">Encoder</span>[<span class="hljs-type">Double</span>] = <span class="hljs-type">Encoders</span>.scalaDouble  &#125;  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;    <span class="hljs-keyword">val</span> spark = <span class="hljs-type">SparkSession</span>.builder()      .master(<span class="hljs-string">"local"</span>)      .appName(<span class="hljs-string">"TSUDAF-Test"</span>)      .getOrCreate()    <span class="hljs-keyword">val</span> rdd = spark.sparkContext.textFile(<span class="hljs-string">"itemdata.data"</span>)    <span class="hljs-keyword">import</span> spark.implicits._    <span class="hljs-keyword">val</span> ds = rdd.map(_.split(<span class="hljs-string">","</span>)).map(d =&gt; <span class="hljs-type">Data</span>(d(<span class="hljs-number">0</span>), d(<span class="hljs-number">1</span>), d(<span class="hljs-number">2</span>).toDouble)).toDS()    <span class="hljs-keyword">val</span> avg = <span class="hljs-keyword">new</span> <span class="hljs-type">MyTSUDAF</span>().toColumn.name(<span class="hljs-string">"avg_score"</span>)    ds.select(avg).show()  &#125;&#125;</code></pre><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><pre><code class="hljs undefined"><span class="hljs-code">+----------------+</span><span class="hljs-section">|       avg_score|+----------------+</span>|8.76923076923077|<span class="hljs-code">+----------------+</span>s</code></pre>]]></content:encoded>
      
      
      
      
      <comments>http://yoursite.com/2020/04/02/Spark%E4%B8%AD%E7%9A%84TSUDAF/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spark中的UDAF</title>
      <link>http://yoursite.com/2020/04/02/Spark%E4%B8%AD%E7%9A%84UDAF/</link>
      <guid>http://yoursite.com/2020/04/02/Spark%E4%B8%AD%E7%9A%84UDAF/</guid>
      <pubDate>Thu, 02 Apr 2020 02:00:29 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;无类型的用户自定于聚合函数（Untyped-User-Defined-Aggregate-Functions）&quot;&gt;&lt;a href=&quot;#无类型的用户自定于聚合函数（Untyped-User-Defined-Aggregate-Functions）&quot; class=&quot;h</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="无类型的用户自定于聚合函数（Untyped-User-Defined-Aggregate-Functions）"><a href="#无类型的用户自定于聚合函数（Untyped-User-Defined-Aggregate-Functions）" class="headerlink" title="无类型的用户自定于聚合函数（Untyped User-Defined Aggregate Functions）"></a>无类型的用户自定于聚合函数（Untyped User-Defined Aggregate Functions）</h1><h2 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h2><p>Itemdata.data</p><pre><code class="hljs undefined"><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">11</span>,<span class="hljs-number">4.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">32</span>,<span class="hljs-number">1.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">176</span>,<span class="hljs-number">27.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">183</span>,<span class="hljs-number">11.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">184</span>,<span class="hljs-number">5.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">207</span>,<span class="hljs-number">9.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">256</span>,<span class="hljs-number">3.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">258</span>,<span class="hljs-number">4.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">259</span>,<span class="hljs-number">16.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">260</span>,<span class="hljs-number">8.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">261</span>,<span class="hljs-number">18.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">301</span>,<span class="hljs-number">1.0</span></code></pre><p>无类型的用户自定于聚合函数需要继承抽象类UserDefinedAggregateFunction，并重写该类的8个函数</p><h2 id="inputSchema"><a href="#inputSchema" class="headerlink" title="inputSchema"></a>inputSchema</h2><p> 定义输入数据的Schema，要求类型是StructType，它的参数是由StructField类型构成的数组。</p><h2 id="bufferSchema"><a href="#bufferSchema" class="headerlink" title="bufferSchema"></a>bufferSchema</h2><p>计算平均数需要用到总和sum和总个数count，bufferSchema用来接收中间计算数据。</p><h2 id="dataType"><a href="#dataType" class="headerlink" title="dataType"></a>dataType</h2><p>申明返回值的类型</p><h2 id="deterministic"><a href="#deterministic" class="headerlink" title="deterministic"></a>deterministic</h2><p>对输入数据进行一致性检验，是一个布尔值，当为true时，表示对于同样的输入会得到同样的输出。</p><h2 id="initialize"><a href="#initialize" class="headerlink" title="initialize"></a>initialize</h2><p>初始化缓存数据。比如score的缓存数据有两个：sum和count，需要初始化为sum=0.0和count=0L。</p><h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><p>更新缓存变量。比如这里当有新的score输入时，需要将它的值更新变量sum中，并将count加1。</p><h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><p>将更新的缓存变量存入到缓存中。</p><h2 id="evaluate"><a href="#evaluate" class="headerlink" title="evaluate"></a>evaluate</h2><p>用于计算我们的最终结果。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><pre><code class="hljs scala"><span class="hljs-keyword">import</span> org.apache.spark.sql.&#123;<span class="hljs-type">Row</span>, <span class="hljs-type">SparkSession</span>&#125;<span class="hljs-keyword">import</span> org.apache.spark.sql.expressions.&#123;<span class="hljs-type">MutableAggregationBuffer</span>, <span class="hljs-type">UserDefinedAggregateFunction</span>&#125;<span class="hljs-keyword">import</span> org.apache.spark.sql.types.&#123;<span class="hljs-type">DataType</span>, <span class="hljs-type">DoubleType</span>, <span class="hljs-type">LongType</span>, <span class="hljs-type">StructField</span>, <span class="hljs-type">StructType</span>&#125;<span class="hljs-comment">/** * 自定义算子测试类 */</span><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">UDAFTest</span> </span>&#123;  <span class="hljs-comment">/**   * 计算平均score   */</span>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyUDAF</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">UserDefinedAggregateFunction</span> </span>&#123;    <span class="hljs-comment">/**     * 计算平均score，输入的应该是score这一列数据     * StructField定义了列字段的名称score_column,字段的类型Double     * StructType要求输入数StructField构成的数组Array，这里只有一列，所以与Nil运算生成Array     * @return StructType     */</span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inputSchema</span></span>: <span class="hljs-type">StructType</span> =      <span class="hljs-type">StructType</span>(        <span class="hljs-type">StructField</span>(<span class="hljs-string">"score_column"</span>, <span class="hljs-type">DoubleType</span>) ::          <span class="hljs-type">Nil</span>)    <span class="hljs-comment">/**     * 缓存Schema，存储中间计算结果，     * 比如计算平均score,需要计算score的总和和score的个数,然后average(score)=sum(score)/count(score)     * 所以这里定义了StructType类型：两个StructField字段：sum和count     * @return StructType     */</span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bufferSchema</span></span>: <span class="hljs-type">StructType</span> =      <span class="hljs-type">StructType</span>(        <span class="hljs-type">StructField</span>(<span class="hljs-string">"sum"</span>, <span class="hljs-type">DoubleType</span>) ::        <span class="hljs-type">StructField</span>(<span class="hljs-string">"count"</span>, <span class="hljs-type">LongType</span>) ::        <span class="hljs-type">Nil</span>)    <span class="hljs-comment">/**     * 自定义集成算子最终返回的数据类型     * 也就是average(score)的类型，所以是Double     * @return DataType 返回数据类型     */</span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dataType</span></span>: <span class="hljs-type">DataType</span> = <span class="hljs-type">DoubleType</span>    <span class="hljs-comment">/**     * 数据一致性检验：对于同样的输入，输出是一样的     * @return Boolean true 同样的输入，输出也一样     */</span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deterministic</span></span>: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">true</span>    <span class="hljs-comment">/**     * 初始化缓存sum和count     * sum=0.0，count=0     * @param buffer 中间数据     */</span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span></span>(buffer: <span class="hljs-type">MutableAggregationBuffer</span>): <span class="hljs-type">Unit</span> = &#123;      buffer(<span class="hljs-number">0</span>) = <span class="hljs-number">0.0</span>      buffer(<span class="hljs-number">1</span>) = <span class="hljs-number">0</span>L    &#125;    <span class="hljs-comment">/**     * 每次计算更新缓存     * @param buffer 缓存数据     * @param input 输入数据score     */</span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update</span></span>(buffer: <span class="hljs-type">MutableAggregationBuffer</span>, input: <span class="hljs-type">Row</span>): <span class="hljs-type">Unit</span> = &#123;      <span class="hljs-keyword">if</span> (!input.isNullAt(<span class="hljs-number">0</span>)) &#123;        buffer(<span class="hljs-number">0</span>) = buffer.getDouble(<span class="hljs-number">0</span>) + input.getDouble(<span class="hljs-number">0</span>)        buffer(<span class="hljs-number">1</span>) = buffer.getLong(<span class="hljs-number">1</span>) + <span class="hljs-number">1</span>      &#125;    &#125;    <span class="hljs-comment">/**     * 将更新后的buffer存储到缓存     * @param buffer1 缓存     * @param buffer2 更新后的buffer     */</span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge</span></span>(buffer1: <span class="hljs-type">MutableAggregationBuffer</span>, buffer2: <span class="hljs-type">Row</span>): <span class="hljs-type">Unit</span> = &#123;      buffer1(<span class="hljs-number">0</span>) = buffer1.getDouble(<span class="hljs-number">0</span>) + buffer2.getDouble(<span class="hljs-number">0</span>)      buffer1(<span class="hljs-number">1</span>) = buffer1.getLong(<span class="hljs-number">1</span>) + buffer2.getLong(<span class="hljs-number">1</span>)    &#125;    <span class="hljs-comment">/**     * 计算最终的结果：average(score)=sum(score)/count(score)     * @param buffer     * @return     */</span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">evaluate</span></span>(buffer: <span class="hljs-type">Row</span>): <span class="hljs-type">Any</span> =      buffer.getDouble(<span class="hljs-number">0</span>) / buffer.getLong(<span class="hljs-number">1</span>)  &#125;  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;    <span class="hljs-keyword">val</span> spark = <span class="hljs-type">SparkSession</span>.builder()      .master(<span class="hljs-string">"local"</span>)      .appName(<span class="hljs-string">"UDAF-Test"</span>)      .getOrCreate()    spark.udf.register(<span class="hljs-string">"myUDAF"</span>, <span class="hljs-keyword">new</span> <span class="hljs-type">MyUDAF</span>)    <span class="hljs-keyword">val</span> df = spark.read.csv(<span class="hljs-string">"itemdata.data"</span>).toDF(<span class="hljs-string">"user_id"</span>, <span class="hljs-string">"item_id"</span>, <span class="hljs-string">"score"</span>)    df.createOrReplaceTempView(<span class="hljs-string">"data"</span>)    spark.sql(<span class="hljs-string">"select myUDAF(score) as avg_score from data"</span>).show()  &#125;&#125;</code></pre><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><pre><code class="hljs undefined"><span class="hljs-code">+----------------+</span><span class="hljs-section">|       avg_score|+----------------+</span><span class="hljs-section">|8.76923076923077|+----------------+</span></code></pre>]]></content:encoded>
      
      
      
      
      <comments>http://yoursite.com/2020/04/02/Spark%E4%B8%AD%E7%9A%84UDAF/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>SparkSQL</title>
      <link>http://yoursite.com/2020/04/01/SparkSQL/</link>
      <guid>http://yoursite.com/2020/04/01/SparkSQL/</guid>
      <pubDate>Wed, 01 Apr 2020 02:15:12 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Spark-SQL&quot;&gt;&lt;a href=&quot;#Spark-SQL&quot; class=&quot;headerlink&quot; title=&quot;Spark SQL&quot;&gt;&lt;/a&gt;Spark SQL&lt;/h1&gt;&lt;h2 id=&quot;架构&quot;&gt;&lt;a href=&quot;#架构&quot; class=&quot;headerlink&quot; </description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Spark-SQL"><a href="#Spark-SQL" class="headerlink" title="Spark SQL"></a>Spark SQL</h1><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><center class="half"><br><img src="/2020/04/01/SparkSQL/架构图.jpg" srcset="/img/loading.gif"><br></center><p><strong>语言API</strong></p><p>Spark与不同的语言和Spark SQL兼容。 它也是由这些语言支持的API（python，scala，java，HiveQL）。</p><p><strong>模式RDD</strong></p><p>Spark Core是使用称为RDD的特殊数据结构设计的。 通常，Spark SQL适用于模式，表和记录。 因此，我们可以使用Schema RDD作为临时表。 我们可以将此Schema RDD称为数据帧。</p><p><strong>数据源</strong></p><p>通常spark-core的数据源是文本文件，Avro文件等。但是，Spark SQL的数据源不同。 这些是Parquet文件，JSON文档，HIVE表和Cassandra数据库。</p><h1 id="Spark-SQL的特点"><a href="#Spark-SQL的特点" class="headerlink" title="Spark SQL的特点"></a>Spark SQL的特点</h1><ol><li>容易集成</li><li>统一的数据访问方式</li><li>兼容Hive</li></ol><h1 id="DataFrame和DataSet"><a href="#DataFrame和DataSet" class="headerlink" title="DataFrame和DataSet"></a>DataFrame和DataSet</h1><ol><li><p>DataFrame</p><p>DataFrame是组织成命名列的<strong>数据集</strong>。它在概念上等同于关系数据库中的<strong>表</strong>，但在底层具有更丰富的优化。DataFrames可以从各种来源构建，</p><p>例如：</p><p>　　结构化数据文件</p><p>　　hive中的表</p><p>　　外部数据库或现有RDDs</p><p>DataFrame API支持的语言有Scala，Java，Python和R。</p><center class="half"><br><img src="/2020/04/01/SparkSQL/RDD和DataFrame.png" srcset="/img/loading.gif"><br></center><p>从上图可以看出，DataFrame多了数据的结构信息，<strong>即schema</strong>。RDD是分布式的 Java对象的集合。DataFrame是分布式的Row对象的集合。DataFrame除了提供了比RDD更丰富的算子以外，更重要的特点是提升执行效率、减少数据读取以及执行计划的优化。</p></li><li><p>DataSet</p><p>Dataset是数据的分布式集合。Dataset是在Spark 1.6中添加的一个新接口，是DataFrame之上更高一级的抽象。它提供了RDD的优点（强类型化，使用强大的lambda函数的能力）以及Spark SQL优化后的执行引擎的优点。一个Dataset 可以从JVM对象构造，然后使用函数转换（map， flatMap，filter等）去操作。 Dataset API 支持Scala和Java。 Python不支持Dataset API。</p></li></ol><h1 id="主要介绍一下DataSet"><a href="#主要介绍一下DataSet" class="headerlink" title="主要介绍一下DataSet"></a>主要介绍一下DataSet</h1><p>Dataset是一个分布式的数据收集器。这是在Spark1.6之后新加的一个接口，兼顾了RDD的优点（<strong>强类型</strong>，可以使用功能强大的lambda）以及Spark SQL的执行器高效性的优点。所以可以把DataFrames看成是一种特殊的Datasets，即：Dataset(Row)</p><center class="half"><br><img src="/2020/04/01/SparkSQL/DataSet.png" srcset="/img/loading.gif"><br></center><p><strong>创建DataSet，方式一：使用序列</strong></p><ol><li><p>定义case class</p><p><code>case class MyData(a:Int,b:String)</code></p></li><li><p>生成序列，并创建DataSet</p><p><code>val ds = Seq(MyData(1,&quot;Tom&quot;),MyData(2,&quot;Mary&quot;)).toDS</code></p></li><li><p>查看结果<br><img src="https://img2018.cnblogs.com/blog/1367933/201810/1367933-20181025100740657-1854671955.png" srcset="/img/loading.gif" alt="img"></p></li></ol><p><strong>创建DataSet，方式二：使用JSON数据</strong></p><ol><li>定义case class</li></ol><p>​       <code>case class Person(name: String, gender: String)</code></p><ol start="2"><li>通过JSON数据生成DataFrame</li></ol><p>​       <code>val df = spark.read.json(sc.parallelize(&quot;&quot;&quot;{&quot;gender&quot;: &quot;Male&quot;, &quot;name&quot;: &quot;Tom&quot;}&quot;&quot;&quot; :: Nil))</code></p><ol start="3"><li>将DataFrame转成DataSet</li></ol><p>​       <code>df.as[Person].show</code></p><p>​        <code>df.as[Person].collect</code></p><p><strong>创建DataSet，方式三：使用HDFS数据</strong></p><ol><li>读取HDFS数据，并创建DataSet</li></ol><p>​        <code>val linesDS = spark.read.text(&quot;hdfs://hadoop111:9000/data/data.txt&quot;).as[String]</code> </p><ol start="2"><li>对DataSet进行操作：分词后，查询长度大于3的单词</li></ol><p>​        <code>val words = linesDS.flatMap(_.split(&quot; &quot;)).filter(_.length &gt; 3)</code></p><p>​        <code>words.show</code></p><p>​        <code>words.collect</code></p><ol start="3"><li>执行WordCount程序</li></ol><p>​       <code>val result = linesDS.flatMap(_.split(&quot; &quot;)).map((_,1)).groupByKey(x =&gt; x._1).count</code></p><p>​       <code>result.show</code></p><p>​       排序：<code>result.orderBy($&quot;value&quot;).show</code></p>]]></content:encoded>
      
      
      
      
      <comments>http://yoursite.com/2020/04/01/SparkSQL/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spark中的RDD</title>
      <link>http://yoursite.com/2020/03/31/Spark%E4%B8%AD%E7%9A%84RDD/</link>
      <guid>http://yoursite.com/2020/03/31/Spark%E4%B8%AD%E7%9A%84RDD/</guid>
      <pubDate>Tue, 31 Mar 2020 09:31:55 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Spark-RDD&quot;&gt;&lt;a href=&quot;#Spark-RDD&quot; class=&quot;headerlink&quot; title=&quot;Spark RDD&quot;&gt;&lt;/a&gt;Spark RDD&lt;/h1&gt;&lt;p&gt;Spark 的核心是建立在统一的抽象弹性分布式数据集（Resiliennt Dist</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Spark-RDD"><a href="#Spark-RDD" class="headerlink" title="Spark RDD"></a>Spark RDD</h1><p>Spark 的核心是建立在统一的抽象弹性分布式数据集（Resiliennt Distributed Datasets，RDD）之上的，这使得 Spark 的各个组件可以无缝地进行集成，能够在同一个应用程序中完成大数据处理。</p><h1 id="RDD概念"><a href="#RDD概念" class="headerlink" title="RDD概念"></a>RDD概念</h1><p>可以将 RDD 理解为一个分布式对象集合，本质上是一个只读的分区记录集合。每个 RDD 可以分成多个分区，每个分区就是一个数据集片段。一个 RDD 的不同分区可以保存到集群中的不同结点上，从而可以在集群中的不同结点上进行并行计算。</p><center class="half"><br><img src="/2020/03/31/Spark中的RDD/RDD运作图.jpg" srcset="/img/loading.gif"><br></center><p>RDD 具有容错机制，并且只读不能修改，可以执行确定的转换操作创建新的 RDD。具体来讲，RDD 具有以下几个属性。</p><ul><li>只读：不能修改，只能通过转换操作生成新的 RDD。</li><li>分布式：可以分布在多台机器上进行并行处理。</li><li>弹性：计算过程中内存不够时它会和磁盘进行数据交换。</li><li>基于内存：可以全部或部分缓存在内存中，在多次计算间重用。</li></ul><h1 id="RDD基本操作"><a href="#RDD基本操作" class="headerlink" title="RDD基本操作"></a>RDD基本操作</h1><p>RDD 的操作分为转化（Transformation）操作和行动（Action）操作。转化操作就是从一个 RDD 产生一个新的 RDD，而行动操作就是进行实际的计算。</p><p>RDD 的操作是惰性的，当 RDD 执行转化操作的时候，实际计算并没有被执行，只有当 RDD 执行行动操作时才会促发计算任务提交，从而执行相应的计算操作。</p><ol><li>构建操作</li></ol><ul><li><p>从内存里直接读取数据。</p><p><code>val rdd01 = sc.makeRDD(List(l,2,3,4,5,6))</code></p></li><li><p>从文件系统里读取数据，文件系统的种类很多，常见的就是 HDFS 及本地文件系统。</p><p><code>val rdd:RDD[String] == sc.textFile(“file://...txt”,1)</code></p></li></ul><ol start="2"><li><p>转换操作</p><center class="half"><br><img src="/2020/03/31/Spark中的RDD/RDD转换.PNG" srcset="/img/loading.gif"><br></center></li><li><p>行动操作</p><center class="half"><br><img src="/2020/03/31/Spark中的RDD/RDD行动.PNG" srcset="/img/loading.gif"><br></center></li></ol><h1 id="RDD和MapReduce的区别"><a href="#RDD和MapReduce的区别" class="headerlink" title="RDD和MapReduce的区别"></a>RDD和MapReduce的区别</h1><p>RDD的概念是为了更快和更高效地实现MapReduce操作</p><h2 id="MapReduce迭代运算"><a href="#MapReduce迭代运算" class="headerlink" title="MapReduce迭代运算"></a>MapReduce迭代运算</h2><p>在多阶段应用程序中跨多个计算重用中间结果。下图说明了当前框架如何工作，同时对MapReduce执行迭代操作。这会由于数据复制，磁盘I / O和序列化而招致大量开销，这使得系统变慢。</p><center class="half"><br><img src="/2020/03/31/Spark中的RDD/MapReduce迭代运算.jpg" srcset="/img/loading.gif"><br></center><h2 id="Spark-RDD迭代运算"><a href="#Spark-RDD迭代运算" class="headerlink" title="Spark RDD迭代运算"></a>Spark RDD迭代运算</h2><p>下图给出了Spark RDD的迭代操作。<strong>它将中间结果存储在分布式存储器中，而不是稳定存储（磁盘）</strong>，并使系统更快。<br>注意 - 如果分布式内存（RAM）不足以存储中间结果（JOB的状态），则它将这些结果存储在磁盘上</p><center class="half"><br><img src="/2020/03/31/Spark中的RDD/RDD迭代运算.jpg" srcset="/img/loading.gif"><br></center>]]></content:encoded>
      
      
      
      
      <comments>http://yoursite.com/2020/03/31/Spark%E4%B8%AD%E7%9A%84RDD/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Hadoop学习笔记</title>
      <link>http://yoursite.com/2020/03/31/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <guid>http://yoursite.com/2020/03/31/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Tue, 31 Mar 2020 01:24:27 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Hadoop简介&quot;&gt;&lt;a href=&quot;#Hadoop简介&quot; class=&quot;headerlink&quot; title=&quot;Hadoop简介&quot;&gt;&lt;/a&gt;Hadoop简介&lt;/h1&gt;&lt;p&gt;Hadoop可运行于一般的商用服务器上，具有高容错、高可靠性、高扩展性等特点。特别适合写一次</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Hadoop简介"><a href="#Hadoop简介" class="headerlink" title="Hadoop简介"></a>Hadoop简介</h1><p>Hadoop可运行于一般的商用服务器上，具有高容错、高可靠性、高扩展性等特点。特别适合写一次，读多次的场景。</p><center class="half"><br><img src="/2020/03/31/Hadoop学习笔记/Hadoop架构.png" srcset="/img/loading.gif"><br></center><ul><li>HDFS：Hadoop Distributed File System 分布式文件存储系统</li><li>YARN：分布式资源管理</li><li>MapReduce：分布式计算</li><li>Others：利用YARN的资源管理功能实现其他的数据处理方式</li></ul><h1 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h1><p>Hadoop Distributed File System，分布式文件系统</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><center class="half"><br><img src="/2020/03/31/Hadoop学习笔记/HDFS架构.png" srcset="/img/loading.gif"><br></center><ul><li><p>Block数据块</p><ol><li>基本存储单位，一般大小为64M。</li><li>大文件会被拆分成一个个块，存储于不同的机器。如果文件小于Block大小，实际的空间为其文件的大小。</li><li>基本的读写单位，类似于磁盘的页，每次都是读写一个块。</li><li>每个块都会被复制到多台机器，默认复制三份。</li></ol></li><li><p>NameNode</p><ol><li>存储文件的metadata，运行时所有数据都保存到内存，整个HDFS可存储的文件数受限于NameNode的内存大小。</li><li>一个Block在NameNode中对应一条记录（一般一个block占用150字节），如果是大量的小文件，会消耗大量内存。同时map task的数量是由splits来决定的，所以用MapReduce处理大量的小文件时，就会产生过多的map task，线程管理开销将会增加作业时间。处理大量小文件的速度远远小于处理同等大小的大文件的速度。因此Hadoop建议存储大文件。</li><li>数据会定时保存到本地磁盘，但不保存block的位置信息，而是由DataNode注册时上报和运行时维护（NameNode中与DataNode相关的信息并不保存到NameNode的文件系统中，而是NameNode每次重启后，动态重建）。</li><li>NameNode失效则整个HDFS都失效了，所以要保证NameNode的可用性。</li></ol></li><li><p>Secondary NameNode</p><p>定时与NameNode进行同步（定期合并文件系统镜像和编辑日志，然后把合并后的传给NameNode，替换其镜像，并清空编辑日志，类似于CheckPoint机制），但NameNode失效后仍需要手工将其设置成主机。</p></li><li><p>DataNode</p><ol><li>保存具体的Block数据。</li><li>负责数据的读写操作和复制操作。</li><li>DataNode启动时会向NameNode报告当前存储的数据块信息，后续也会定时报告修改信息。</li><li>DataNode之间会进行通信，复制数据块，保证数据的冗余性。</li></ol></li></ul><h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><center class="half"><br><img src="/2020/03/31/Hadoop学习笔记/HDFS写文件.png" srcset="/img/loading.gif"><br></center><ol><li><p>客户端将文件写入本地磁盘的HDFS Client文件中</p></li><li><p>当临时文件大小达到一个block大小时，HDFS client通知NameNode，申请写入文件</p></li><li><p>NameNode在HDFS的文件系统中创建一个文件，并把该block id和要写入的DataNode的列表返回给客户端</p></li><li><p>客户端收到这些信息后，将临时文件写入DataNodes</p></li></ol><ul><li>4.1 客户端将文件内容写入第一个DataNode（一般以4kb为单位进行传输）</li><li>4.2 第一个DataNode接收后，将数据写入本地磁盘，同时也传输给第二个DataNode</li><li>4.3 依此类推到最后一个DataNode，数据在DataNode之间是通过pipeline的方式进行复制的</li><li>4.4 后面的DataNode接收完数据后，都会发送一个确认给前一个DataNode，最终第一个DataNode返回确认给客户端</li><li>4.5 当客户端接收到整个block的确认后，会向NameNode发送一个最终的确认信息</li><li>4.6 如果写入某个DataNode失败，数据会继续写入其他的DataNode。然后NameNode会找另外一个好的DataNode继续复制，以保证冗余性</li><li>4.7 每个block都会有一个校验码，并存放到独立的文件中，以便读的时候来验证其完整性</li></ul><ol start="5"><li>文件写完后（客户端关闭），NameNode提交文件（这时文件才可见，如果提交前，NameNode垮掉，那文件也就丢失了。fsync：只保证数据的信息写到NameNode上，但并不保证数据已经被写到DataNode中）</li></ol><h2 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h2><center class="half"><br><img src="/2020/03/31/Hadoop学习笔记/HDFS读文件.png" srcset="/img/loading.gif"><br></center><ol><li>客户端向NameNode发送读取请求</li><li>NameNode返回文件的所有block和这些block所在的DataNodes（包括复制节点）</li><li>客户端直接从DataNode中读取数据，如果该DataNode读取失败（DataNode失效或校验码不对），则从复制节点中读取（如果读取的数据就在本机，则直接读取，否则通过网络读取）</li></ol><h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><ol><li><p>DataNode可以失效</p><p>DataNode会定时发送心跳到NameNode。如果一段时间内NameNode没有收到DataNode的心跳消息，则认为其失效。此时NameNode就会将该节点的数据（从该节点的复制节点中获取）复制到另外的DataNode中。</p></li><li><p>数据可以毁坏</p><p>无论是写入时还是硬盘本身的问题，只要数据有问题（读取时通过校验码来检测），都可以通过其他的复制节点读取，同时还会再复制一份到健康的节点中。</p></li><li><p>NameNode不可靠</p></li></ol><h1 id="YARN"><a href="#YARN" class="headerlink" title="YARN"></a>YARN</h1><h2 id="旧MapReduce架构"><a href="#旧MapReduce架构" class="headerlink" title="旧MapReduce架构"></a>旧MapReduce架构</h2><center class="half"><br><img src="/2020/03/31/Hadoop学习笔记/旧MapReduce架构.jpg" srcset="/img/loading.gif"><br></center><ul><li>JobTracker：作业生命周期管理（调度作业任务、跟踪进度、为任务提供容错）。</li><li>TaskTracker：加载或关闭任务，定时报告任务状态。</li></ul><p><em>存在的问题：</em></p><ol><li>obTracker是MapReduce的集中处理点，存在单点故障。</li><li>JobTracker完成了太多的任务，造成了过多的资源消耗，当MapReduce job 非常多的时候，会造成很大的内存开销。这也是业界普遍总结出老Hadoop的MapReduce只能支持4000 节点主机的上限。</li><li>在TaskTracker端，以map/reduce task的数目作为资源的表示过于简单，没有考虑到cpu/ 内存的占用情况，如果两个大内存消耗的task被调度到了一块，很容易出现OOM（OutOfMemory）。</li><li>在TaskTracker端，把资源强制划分为map task slot和reduce task slot, 如果当系统中只有map task或者只有reduce task的时候，会造成资源的浪费，也就集群资源利用的问题。</li></ol><h2 id="YARN架构"><a href="#YARN架构" class="headerlink" title="YARN架构"></a>YARN架构</h2><center class="half"><br><img src="/2020/03/31/Hadoop学习笔记/YARN架构1.jpg" srcset="/img/loading.gif"><br><img src="/2020/03/31/Hadoop学习笔记/YARN架构2.jpg" srcset="/img/loading.gif"><br></center><p>YARN就是将JobTracker的职责进行拆分，将资源管理和任务调度监控拆分成独立#x7ACB;的进程：一个全局的资源管理和一个每个作业的管理（ApplicationMaster） ResourceManager和NodeManager提供了计算资源的分配和管理，而ApplicationMaster则完成应用程序的运行</p><ul><li><strong>ResourceManager:</strong> 全局资源管理和任务调度</li><li><strong>NodeManager:</strong> 单个节点的资源管理和监控</li><li><strong>ApplicationMaster:</strong> 单个作业的资源管理和任务监控</li><li><strong>Container:</strong> 资源申请的单位和任务运行的容器</li></ul><h1 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h1><p>一种分布式的计算方式指定一个Map（映#x5C04;）函数，用来把一组键值对映射成一组新的键值对，指定并发的Reduce（归约）函数，用来保证所有映射的键值对中的每一个共享相同的键组。</p><p><em>详细流程</em></p><center class="half"><br><img src="/2020/03/31/Hadoop学习笔记/mapreduce-process.png" srcset="/img/loading.gif"><br></center>]]></content:encoded>
      
      
      
      
      <comments>http://yoursite.com/2020/03/31/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Https和Http的区别</title>
      <link>http://yoursite.com/2020/02/27/Https%E5%92%8CHttp%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <guid>http://yoursite.com/2020/02/27/Https%E5%92%8CHttp%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <pubDate>Thu, 27 Feb 2020 02:01:51 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;昨天在做毕设开发安卓端，向个人服务器请求数据的时候，遇到了&lt;code&gt;CLEARTEXT communication to *** not </description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>昨天在做毕设开发安卓端，向个人服务器请求数据的时候，遇到了<code>CLEARTEXT communication to *** not permitted by network security policy</code>的问题。搜索后发现是谷歌对于新版的安卓系统限制了非加密的流量请求。</p><p>解决方法有两种：</p><ol><li>把所有的http请求全部改为https请求</li><li>在AndroidManifest.xml中配置<code>cleartextTrafficPermitted=&quot;true&quot;</code></li></ol><p>此前对Https只停留在比Http安全这个理解层面，今天进行一下全面了解并做记录</p><h1 id="Https是什么？"><a href="#Https是什么？" class="headerlink" title="Https是什么？"></a>Https是什么？</h1><p><strong>HTTPS=HTTP over SSL/TLS，也就是说，HTTPS 在传输层 TCP 和应用层 HTTP 之间，多走了一层 SSL/TLS。</strong></p><center class="half"><br><img src="/2020/02/27/Https和Http的区别/Https图解.jpeg" srcset="/img/loading.gif"><br></center><p>由上图可以看出，<strong>TLS/SSL 是 HTTPS 的核心</strong>。</p><center class="half"><br><img src="/2020/02/27/Https和Http的区别/SSL图解.jpeg" srcset="/img/loading.gif"><br></center><p><strong>SSL/TLS 协议作用在传输层和应用层之间，对应用层数据进行加密传输。</strong></p><h1 id="为什么Https更安全"><a href="#为什么Https更安全" class="headerlink" title="为什么Https更安全"></a>为什么Https更安全</h1><p>HTTP 1.1 版本存在一个很大的问题-<strong>明文传输（Plaintext/Clear Text）</strong>，这个问题在互联网时代的今天是致命的，一旦数据在公共网络中被第三方截获，其通信内容轻而易举地就被窃取了。而这个明文传输也是在谷歌新版安卓系统上默认被禁止了。</p><p>为了解决这个问题，Https出现，它有三大优势：</p><ol><li><strong>数据加密，防窃听</strong></li><li><strong>身份验证，防冒充</strong></li><li><strong>完整性校验，防篡改</strong></li></ol><h2 id="数据加密"><a href="#数据加密" class="headerlink" title="数据加密"></a>数据加密</h2><p>Https同时拥有对称加密和非对称加密。前者只有一把密钥做加解密；后者有两把密钥，公钥和私钥，互为加解密，公钥给对方，私钥自己用。</p><h2 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h2><p><strong>数字证书用于主体身份验证。</strong></p><p>在 Chrome 浏览器上点击地址栏的“锁”标记后会出现下拉框，接着点击“证书”即可看到通过 HTTPS 访问该服务器时的数字证书。</p><center class="half"><br><img src="/2020/02/27/Https和Http的区别/Https证书.png" srcset="/img/loading.gif"><br></center><p>一张完整的数字证书包括：</p><ul><li><p><strong>主体的必要信息：版本(version)、序列号(serialNumber)、签名算法(signatureAlgorithm)、颁发者(issuer)、有效期(validity)、使用者(subject)、公钥信息(subjectPublicKeyInfo)</strong></p></li><li><p><strong>主体的扩展信息(extension)：如密钥标识符、证书策略等</strong></p></li><li><p><strong>数字签名(signature)，也称指纹</strong></p></li><li><center class="half"><br><img src="/2020/02/27/Https和Http的区别/数字证书.jpeg" srcset="/img/loading.gif"><br></center></li></ul><h2 id="完整性校验"><a href="#完整性校验" class="headerlink" title="完整性校验"></a>完整性校验</h2><p><strong>哈希</strong>，键值对数据结构，通过哈希函数把一个空间映射到另一个空间。非常好用的一个工具，比如负载均衡的一致性哈希、密码学中用于信息加密或数据校验的各种哈希（SHA、MD5 等）、二维空间定位的 GeoHash、对象相似度的 SimHash 等等。</p>]]></content:encoded>
      
      
      
      
      <comments>http://yoursite.com/2020/02/27/Https%E5%92%8CHttp%E7%9A%84%E5%8C%BA%E5%88%AB/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>算法-二分查找法</title>
      <link>http://yoursite.com/2020/02/22/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/</link>
      <guid>http://yoursite.com/2020/02/22/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/</guid>
      <pubDate>Sat, 22 Feb 2020 02:49:38 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;二分查找也称为折半查找，每次都能将查找区间减半，这种折半特性的算法时间复杂度为 O(logN)。&lt;/p&gt;
&lt;h1 id=&quot;关键&quot;&gt;&lt;a hr</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>二分查找也称为折半查找，每次都能将查找区间减半，这种折半特性的算法时间复杂度为 O(logN)。</p><h1 id="关键"><a href="#关键" class="headerlink" title="关键"></a>关键</h1><p>计算中值<strong>m</strong>，有两种方式：</p><ul><li>m = (l + h) / 2</li><li>m = l + (h - l) / 2</li></ul><p>第一种方式 l + h 可能出现加法溢出的情况，推荐使用第二种</p><h1 id="正常实现方式"><a href="#正常实现方式" class="headerlink" title="正常实现方式"></a>正常实现方式</h1><pre><code class="hljs undefined">Input : [1,2,3,4,5]key : 3<span class="hljs-keyword">return</span> the index : 2</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> key)</span> </span>&#123;    <span class="hljs-comment">// l 最低位 h 最高位</span>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, h = nums.length - <span class="hljs-number">1</span>;    <span class="hljs-comment">// 进入二分查找循环体</span>    <span class="hljs-keyword">while</span> (l &lt;= h) &#123;        <span class="hljs-comment">// 计算中值</span>        <span class="hljs-keyword">int</span> m = l + (h - l) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span> (nums[m] == key) &#123;          <span class="hljs-comment">// m 个元素为查找值，返回结果</span>            <span class="hljs-keyword">return</span> m;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[m] &gt; key) &#123;          <span class="hljs-comment">// m 个元素大于查找值，h 移动到 m - 1</span>            h = m - <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// m 个元素小于查找值，l 移动到 m + 1</span>            l = m + <span class="hljs-number">1</span>;        &#125;    &#125;  <span class="hljs-comment">// 循环结束没有找到值，返回 -1 ，表示没有找到</span>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre>]]></content:encoded>
      
      
      
      
      <comments>http://yoursite.com/2020/02/22/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>RESTful的一些状态码记录</title>
      <link>http://yoursite.com/2020/02/19/RESTful%E7%9A%84%E4%B8%80%E4%BA%9B%E7%8A%B6%E6%80%81%E7%A0%81%E8%AE%B0%E5%BD%95/</link>
      <guid>http://yoursite.com/2020/02/19/RESTful%E7%9A%84%E4%B8%80%E4%BA%9B%E7%8A%B6%E6%80%81%E7%A0%81%E8%AE%B0%E5%BD%95/</guid>
      <pubDate>Wed, 19 Feb 2020 09:18:56 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;RESTFUL（&lt;strong&gt;Representational State Transfer&lt;/strong&gt;）是一种网络应用程序的设计风</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>RESTFUL（<strong>Representational State Transfer</strong>）是一种网络应用程序的设计风格和开发方式，基于<a href="https://baike.baidu.com/item/HTTP/243074" target="_blank" rel="noopener">HTTP</a>，可以使用<a href="https://baike.baidu.com/item/XML/86251" target="_blank" rel="noopener">XML</a>格式定义或<a href="https://baike.baidu.com/item/JSON/2462549" target="_blank" rel="noopener">JSON</a>格式定义。RESTFUL适用于移动互联网厂商作为业务使能接口的场景，实现第三方<a href="https://baike.baidu.com/item/OTT/9960940" target="_blank" rel="noopener">OTT</a>调用移动网络资源的功能，动作类型为新增、变更、删除所调用资源。</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>RESTFUL特点包括：</p><ol><li><p>每一个URI代表1种资源；</p></li><li><p>客户端使用GET、POST、PUT、DELETE4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源；</p></li><li><p>通过操作资源的表现形式来操作资源；</p></li><li><p>资源的表现形式是XML或者JSON；</p></li><li><p>客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都必须包含理解请求所必需的信息。</p></li></ol><h1 id="四种操作对应的状态码"><a href="#四种操作对应的状态码" class="headerlink" title="四种操作对应的状态码"></a>四种操作对应的状态码</h1><h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><p>安全且幂等<br>获取表示<br>变更时获取表示（缓存） </p><table><thead><tr><th>状态码</th><th>解释</th></tr></thead><tbody><tr><td>200</td><td>（OK）表示已在响应中发出</td></tr><tr><td>204</td><td>（无内容） 资源有空表示</td></tr><tr><td>301</td><td>（Moved Permanently）资源的URI已被更新</td></tr><tr><td>303</td><td>（See Other）其他（如，负载均衡）</td></tr><tr><td>304</td><td>（not modified）资源未更改（缓存）</td></tr><tr><td>400</td><td>（bad request）指代坏请求（如，参数错误）</td></tr><tr><td>404</td><td>（not found）资源不存在</td></tr><tr><td>406</td><td>（not acceptable）服务端不支持所需表示</td></tr><tr><td>500</td><td>（internal server error）通用错误响应</td></tr><tr><td>503</td><td>（Service Unavailable）服务端当前无法处理请求</td></tr></tbody></table><h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><p>不安全且不幂等<br>使用服务端管理的（自动产生）的实例号创建资源<br>创建子资源<br>部分更新资源<br>如果没有被修改，则不过更新资源（乐观锁）</p><table><thead><tr><th>状态码</th><th>解释</th></tr></thead><tbody><tr><td>200</td><td>（OK）如果现有资源已被更改</td></tr><tr><td>201</td><td>（created）如果新资源被创建</td></tr><tr><td>202</td><td>（accepted）已接受处理请求但尚未完成（异步处理）</td></tr><tr><td>301</td><td>（Moved Permanently）资源的URI被更新</td></tr><tr><td>303</td><td>（See Other）其他（如，负载均衡）</td></tr><tr><td>400</td><td>（bad request）指代坏请求</td></tr><tr><td>404</td><td>（not found）资源不存在</td></tr><tr><td>406</td><td>（not acceptable）服务端不支持所需表示</td></tr><tr><td>409</td><td>（conflict）通用冲突</td></tr><tr><td>412</td><td>（Precondition Failed）前置条件失败（如执行条件更新时的冲突）</td></tr><tr><td>415</td><td>（unsupported media type）接受到的表示不受支持</td></tr><tr><td>500</td><td>（internal server error）通用错误响应</td></tr><tr><td>503</td><td>（Service Unavailable）服务当前无法处理请求</td></tr></tbody></table><h2 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h2><p>不安全但幂等<br>用客户端管理的实例号创建一个资源<br>通过替换的方式更新资源<br>如果未被修改，则更新资源（乐观锁）</p><table><thead><tr><th>状态码</th><th>解释</th></tr></thead><tbody><tr><td>200</td><td>（OK）如果已存在资源被更改</td></tr><tr><td>201</td><td>（created）如果新资源被创建</td></tr><tr><td>301</td><td>（Moved Permanently）资源的URI已更改</td></tr><tr><td>303</td><td>（See Other）其他（如，负载均衡）</td></tr><tr><td>400</td><td>（bad request）指代坏请求</td></tr><tr><td>404</td><td>（not found）资源不存在</td></tr><tr><td>406</td><td>（not acceptable）服务端不支持所需表示</td></tr><tr><td>409</td><td>（conflict）通用冲突</td></tr><tr><td>412</td><td>（Precondition Failed）前置条件失败（如执行条件更新时的冲突）</td></tr><tr><td>415</td><td>（unsupported media type）接受到的表示不受支持</td></tr><tr><td>500</td><td>（internal server error）通用错误响应</td></tr><tr><td>503</td><td>（Service Unavailable）服务当前无法处理请求</td></tr></tbody></table><h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><p>不安全但幂等<br>删除资源</p><table><thead><tr><th>状态码</th><th>解释</th></tr></thead><tbody><tr><td>200</td><td>（OK）资源已被删除</td></tr><tr><td>301</td><td>（Moved Permanently）资源的URI已更改</td></tr><tr><td>303</td><td>（See Other）其他，如负载均衡</td></tr><tr><td>400</td><td>（bad request）指代坏请求</td></tr><tr><td>404</td><td>（not found）资源不存在</td></tr><tr><td>409</td><td>（conflict）通用冲突</td></tr><tr><td>500</td><td>（internal server error）通用错误响应</td></tr><tr><td>503</td><td>（Service Unavailable）服务端当前无法处理请求</td></tr></tbody></table>]]></content:encoded>
      
      
      
      
      <comments>http://yoursite.com/2020/02/19/RESTful%E7%9A%84%E4%B8%80%E4%BA%9B%E7%8A%B6%E6%80%81%E7%A0%81%E8%AE%B0%E5%BD%95/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>CocoaTouch中的UIApplication</title>
      <link>http://yoursite.com/2019/10/23/CocoaTouch%E4%B8%AD%E7%9A%84UIApplication/</link>
      <guid>http://yoursite.com/2019/10/23/CocoaTouch%E4%B8%AD%E7%9A%84UIApplication/</guid>
      <pubDate>Wed, 23 Oct 2019 01:25:18 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;UIApplication干什么的？&quot;&gt;&lt;a href=&quot;#UIApplication干什么的？&quot; class=&quot;headerlink&quot; title=&quot;UIApplication干什么的？&quot;&gt;&lt;/a&gt;UIApplication干什么的？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="UIApplication干什么的？"><a href="#UIApplication干什么的？" class="headerlink" title="UIApplication干什么的？"></a>UIApplication干什么的？</h2><ul><li>UIApplication 的核心作用是提供了 iOS 程序运行期间的控制和协作工作。</li><li>每一个程序在运行期必须有且仅有一个 UIApplication（或则其子类）的一个实例。在程序开始运行的时候，UIApplicationMain 函数是程序进入点，这个函数做了很多工作，其中一个重要的工作就是创建一个 UIApplication 的单例实例。在你的代码中你，你可以通过调用 [UIApplication sharedApplication] 来得到这个单例实例的指针。</li><li>UIApplication 的一个主要工作是处理用户事件，它会起一个队列，把所有用户事件都放入队列，逐个处理，在处理的时候，它会发送当前事件 到一个合适的处理事件的目标控件。此外，UIApplication 实例还维护一个在本应用中打开的 window 列表（UIWindow 实例），这样它就 可以接触应用中的任何一个 UIView 对象。UIApplication 实例会被赋予一个代理对象，以处理应用程序的生命周期事件（比如程序启动和关闭）、系统事件（比如来电、记事项警告）等等。</li></ul><h2 id="UIApplication生命周期"><a href="#UIApplication生命周期" class="headerlink" title="UIApplication生命周期"></a>UIApplication生命周期</h2><ul><li><p>一个 UIApplication 可以有如下几种状态：</p><ul><li><code>Not running（未运行）</code>程序没启动</li><li><code>Inactive（未激活）</code>程序在前台运行，不过没有接收到事件。在没有事件处理情况下程序通常停留在这个状态</li><li><code>Active（激活）</code>程序在前台运行而且接收到了事件。这也是前台的一个正常的模式</li><li><code>Background（后台）</code> 程序在后台而且能执行代码，大多数程序进入这个状态后会在在这个状态上停留一会。时间到之后会进入挂起状态 (Suspended)。有的程序经过特殊的请求后可以长期处于 Background 状态</li><li><p><code>Suspended（挂起）</code>程序在后台不能执行代码。系统会自动把程序变成这个状态而且不会发出通知。当挂起时，程序还是停留在内存中的，当系统内存低时，系统就把挂起的程序清除掉，为前台程序提供更多的内存。</p></li><li><p>常见的代理方法有</p></li></ul><ol><li><p><code>(void)applicationWillResignActive:(UIApplication *)application</code></p><p>说明：当应用程序将要入非活动状态执行，在此期间，应用程序不接收消息或事件，比如来电话了</p></li><li><p><code>(void)applicationDidBecomeActive:(UIApplication *)application</code></p><p>说明：当应用程序入活动状态执行，这个刚好跟上面那个方法相反</p></li><li><p><code>(void)applicationDidEnterBackground:(UIApplication *)application</code></p><p>说明：当程序被推送到后台的时候调用。所以要设置后台继续运行，则在这个函数里面设置即可</p></li><li><p><code>(void)applicationWillEnterForeground:(UIApplication *)application</code></p><p>说明：当程序从后台将要重新回到前台时候调用，这个刚好跟上面的那个方法相反。</p></li><li><p><code>(void)applicationWillTerminate:(UIApplication *)application</code></p><p>说明：当程序将要退出是被调用，通常是用来保存数据和一些退出前的清理工作。这个需要设置 UIApplicationExitsOnSuspend 的键值。</p></li><li><p><code>(void)applicationDidReceiveMemoryWarning:(UIApplication *)application</code></p><p>说明：iPhone 设备只有有限的内存，如果为应用程序分配了太多内存操作系统会终止应用程序的运行，在终止前会执行这个方法，通常可以在这里进行内存清理工作防止程序被终止</p></li><li><p><code>(void)applicationSignificantTimeChange:(UIApplication*)application</code></p><p>说明：当系统时间发生改变时执行</p></li><li><p><code>(void)applicationDidFinishLaunching:(UIApplication*)application</code></p><p>说明：当程序载入后执行</p></li></ol></li></ul>]]></content:encoded>
      
      
      
      
      <comments>http://yoursite.com/2019/10/23/CocoaTouch%E4%B8%AD%E7%9A%84UIApplication/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Objective-C中的Runtime</title>
      <link>http://yoursite.com/2019/10/22/Objective-C%E4%B8%AD%E7%9A%84Runtime/</link>
      <guid>http://yoursite.com/2019/10/22/Objective-C%E4%B8%AD%E7%9A%84Runtime/</guid>
      <pubDate>Tue, 22 Oct 2019 06:04:53 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;OC和C的区别&quot;&gt;&lt;a href=&quot;#OC和C的区别&quot; class=&quot;headerlink&quot; title=&quot;OC和C的区别&quot;&gt;&lt;/a&gt;OC和C的区别&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;OC是动态语言，C是静态语言。&lt;/li&gt;
&lt;li&gt;OC的函数调用在编译期无法确定，C的函</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="OC和C的区别"><a href="#OC和C的区别" class="headerlink" title="OC和C的区别"></a>OC和C的区别</h2><ul><li>OC是动态语言，C是静态语言。</li><li>OC的函数调用在编译期无法确定，C的函数调用在编译期就已经决定。</li><li>Runtime就是去解决如何在运行期间找到调用方法的问题。</li></ul><h2 id="什么是Runtime"><a href="#什么是Runtime" class="headerlink" title="什么是Runtime"></a>什么是Runtime</h2><ul><li><p>对于实例变量有如下的思路：</p><blockquote><p>instance -&gt; class -&gt; method -&gt; SEL -&gt; IMP -&gt; 实现函数</p></blockquote></li><li><p>实例对象中存放 isa 指针以及实例变量，有 isa 指针可以找到实例对象所属的类对象 (类也是对象，面向对象中一切都是对象)，类中存放着实例方法列表，在这个方法列表中 SEL 作为 key，IMP 作为 value。 在编译时期，根据方法名字会生成一个唯一的 Int 标识，这个标识就是 SEL。IMP 其实就是函数指针 指向了最终的函数实现。整个 Runtime 的核心就是 objc_msgSend 函数，通过给类发送 SEL 以传递消息，找到匹配的 IMP 再获取最终的实现。如下的这张图描述了对象的内存布局。</p></li><li><p><img src="/2019/10/22/Objective-C中的Runtime/对象的内存布局.png" srcset="/img/loading.gif" alt="对象的内存布局"></p></li><li><p>类中的 super_class 指针可以追溯整个继承链。向一个对象发送消息时，Runtime 会根据实例对象的 isa 指针找到其所属的类，并自底向上直至根类(NSObject)中 去寻找 SEL 所对应的方法，找到后就运行整个方法。</p></li><li><p>metaClass是元类，也有 isa 指针、super_class 指针。其中保存了类方法列表。</p></li></ul><h2 id="消息传递机制"><a href="#消息传递机制" class="headerlink" title="消息传递机制"></a>消息传递机制</h2><ul><li>objc_msgSend函数的消息处理过程</li><li>不涵盖消息cache机制</li><li>需要对Objective-C runtime有一定的了解</li></ul><p>如下用于描述 objc_msgSend 函数的调用流程：</p><ul><li>1.检测 SEL 是否应该被忽略</li><li>2.检测发送的 target 是否为 nil ，如果是则忽略该消息</li><li>3.<ul><li>当调用实例方法时，通过 isa 指针找到实例对应的 class 并且在其中的缓存方法列表以及方法列表中进行查询，如果找不到则根据 super_class 指针在父类中查询，直至根类(NSObject 或 NSProxy).</li><li>当调用类方法时，通过 isa 指针找到实例对应的 metaclass 并且在其中的缓存方法列表以及方法列表中进行查询，如果找不到则根据 super_class 指针在父类中查询，直至根类(NSObject 或 NSProxy). (根据此前的开篇中的图，Root Meta Class 还是有根类的。)</li></ul></li><li>如果还没找到则进入消息动态解析过程。</li></ul><h2 id="动态消息解析"><a href="#动态消息解析" class="headerlink" title="动态消息解析"></a>动态消息解析</h2><ul><li><p><img src="/2019/10/22/Objective-C中的Runtime/动态消息解析.png" srcset="/img/loading.gif" alt="动态消息解析"></p></li><li><p>如下用于描述动态消息解析的流程:</p><ul><li>1.通过 resolveInstanceMethod 得知方法是否为动态添加，YES则通过 class_addMethod 动态添加方法，处理消息，否则进入下一步。dynamic 属性就与这个过程有关，当一个属性声明为 dynamic 时 就是告诉编译器：开发者一定会添加 setter/getter 的实现，而编译时不用自动生成。</li><li>2.这步会进入 forwardingTargetForSelector 用于指定哪个对象来响应消息。如果返回nil 则进入第三步。这种方式把消息原封不动地转发给目标对象，有着比较高的效率。如果不能自己的类里面找到替代方法，可以重载这个方法，然后把消息转给其他的对象。</li><li>3.这步调用 methodSignatureForSelector 进行方法签名，这可以将函数的参数类型和返回值封装。如果返回 nil 说明消息无法处理并报错 <code>unrecognized selector sent to instance</code>，如果返回 methodSignature，则进入 forwardInvocation ，在这里可以修改实现方法，修改响应对象等，如果方法调用成功，则结束。如果依然不能正确响应消息，则报错 <code>unrecognized selector sent to instance</code>.</li></ul><p>可以利用 2、3 中的步骤实现对接受消息对象的转移，可以实现“多重继承”的效果。</p></li></ul><p>参考资料：</p><p><a href="https://hit-alibaba.github.io/interview/iOS/ObjC-Basic/Runtime.html" target="_blank" rel="noopener">https://hit-alibaba.github.io/interview/iOS/ObjC-Basic/Runtime.html</a></p>]]></content:encoded>
      
      
      
      
      <comments>http://yoursite.com/2019/10/22/Objective-C%E4%B8%AD%E7%9A%84Runtime/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>CocoaTouch中的事件处理</title>
      <link>http://yoursite.com/2019/10/21/CocoaTouch%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</link>
      <guid>http://yoursite.com/2019/10/21/CocoaTouch%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</guid>
      <pubDate>Mon, 21 Oct 2019 10:19:10 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;事件分类&quot;&gt;&lt;a href=&quot;#事件分类&quot; class=&quot;headerlink&quot; title=&quot;事件分类&quot;&gt;&lt;/a&gt;事件分类&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;触屏事件(Touch Event)&lt;/li&gt;
&lt;li&gt;运动事件(Motion Event)&lt;/li&gt;
&lt;li&gt;远</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="事件分类"><a href="#事件分类" class="headerlink" title="事件分类"></a>事件分类</h2><ol><li>触屏事件(Touch Event)</li><li>运动事件(Motion Event)</li><li>远端控制事件(Remote-Control Event)</li></ol><h2 id="响应者链"><a href="#响应者链" class="headerlink" title="响应者链"></a>响应者链</h2><ul><li><p>当发生事件响应时，必须知道由谁来响应事件。在 iOS 中，由响应者链来对事件进行响应。</p></li><li><p>所有事件响应的类都是 UIResponder 的子类，响应者链是一个由不同对象组成的层次结构，其中的每个对象将依次获得响应事件消息的机会。当发生事件时，事件首先被发送给第一响应者，第一响应者往往是事件发生的视图，也就是用户触摸屏幕的地方。事件将沿着响应者链一直向下传递，直到被接受并做出处理。一般来说，第一响应者是个视图对象或者其子类对象，当其被触摸后事件被交由它处理，如果它不处理，事件就会被传递给它的视图控制器对象 ViewController（如果存在），然后是它的父视图（superview）对象（如果存在），以此类推，直到顶层视图。接下来会沿着顶层视图（top view）到窗口（UIWindow 对象）再到程序（UIApplication 对象）。如果整个过程都没有响应这个事件，该事件就被丢弃。一般情况下，在响应者链中只要由对象处理事件，事件就停止传递。</p></li><li><p>一个典型的事件响应路线如下：</p><pre><code class="hljs undefined">F<span class="hljs-function"><span class="hljs-title">irst</span> Responser --&gt;</span> T<span class="hljs-function"><span class="hljs-title">he</span> Window --&gt;</span> T<span class="hljs-function"><span class="hljs-title">he</span> Application --&gt;</span> <span class="hljs-literal">nil</span>（丢弃）</code></pre></li><li><p>我们可以通过 <code>[responder nextResponder]</code> 找到当前 responder 的下一个 responder，持续这个过程到最后会找到 UIApplication 对象。</p></li><li><p>通常情况下，我们在 First Responder （一般也就是用户当前触控的 View ）这里就会响应请求，进入下面的事件分发机制。</p></li></ul><h2 id="事件分发"><a href="#事件分发" class="headerlink" title="事件分发"></a>事件分发</h2><ul><li>第一响应者（First responder）指的是当前接受触摸的响应者对象（通常是一个 UIView 对象），即表示当前该对象正在与用户交互，它是响应者链的开端。响应者链和事件分发的使命都是找出第一响应者。</li><li>iOS 系统检测到手指触摸 (Touch) 操作时会将其打包成一个 UIEvent 对象，并放入当前活动 Application 的事件队列，单例的 UIApplication 会从事件队列中取出触摸事件并传递给单例的 UIWindow 来处理，UIWindow 对象首先会使用 <code>hitTest:withEvent:</code>方法寻找此次 Touch 操作初始点所在的视图(View)，即需要将触摸事件传递给其处理的视图，这个过程称之为 hit-test view。</li><li><code>hitTest:withEvent:</code>方法的处理流程如下:<ul><li>首先调用当前视图的 <code>pointInside:withEvent:</code> 方法判断触摸点是否在当前视图内；</li><li>若返回 NO, 则 <code>hitTest:withEvent:</code> 返回 nil，若返回 YES, 则向当前视图的所有子视图 (subviews) 发送 <code>hitTest:withEvent:</code> 消息，所有子视图的遍历顺序是从最顶层视图一直到到最底层视图，即从 subviews 数组的末尾向前遍历，直到有子视图返回非空对象或者全部子视图遍历完毕；</li><li>若第一次有子视图返回非空对象，则 <code>hitTest:withEvent:</code> 方法返回此对象，处理结束；</li><li>如所有子视图都返回空，则 hitTest:withEvent: 方法返回自身 (self)。</li></ul></li></ul>]]></content:encoded>
      
      
      
      
      <comments>http://yoursite.com/2019/10/21/CocoaTouch%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Objective-C中的内存管理</title>
      <link>http://yoursite.com/2019/10/20/Objective-C%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
      <guid>http://yoursite.com/2019/10/20/Objective-C%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
      <pubDate>Sun, 20 Oct 2019 05:37:26 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;OC的内存分配机制&quot;&gt;&lt;a href=&quot;#OC的内存分配机制&quot; class=&quot;headerlink&quot; title=&quot;OC的内存分配机制&quot;&gt;&lt;/a&gt;OC的内存分配机制&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;OC中，对象通过alloc在堆上创建，一旦对象创建完成，就不能在再移动。</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="OC的内存分配机制"><a href="#OC的内存分配机制" class="headerlink" title="OC的内存分配机制"></a>OC的内存分配机制</h2><ul><li>OC中，对象通过alloc在堆上创建，一旦对象创建完成，就不能在再移动。</li></ul><h2 id="MRC和ARC"><a href="#MRC和ARC" class="headerlink" title="MRC和ARC"></a>MRC和ARC</h2><ul><li>OC中提供两种内存管理机制：MRC(Mannual Reference Counting)和ARC(Automatic Reference Counting)，指手动和自动管理，现在推荐使用ARC来管理内存。</li></ul><h2 id="MRC"><a href="#MRC" class="headerlink" title="MRC"></a>MRC</h2><table><thead><tr><th>对象操作</th><th style="text-align:center">OC中对应的方法</th><th style="text-align:center">对应的 retainCount 变化</th></tr></thead><tbody><tr><td>生成并持有对象</td><td style="text-align:center">alloc/new/copy/mutableCopy等</td><td style="text-align:center">+1</td></tr><tr><td>持有对象</td><td style="text-align:center">retain</td><td style="text-align:center">+1</td></tr><tr><td>释放对象</td><td style="text-align:center">release</td><td style="text-align:center">-1</td></tr><tr><td>废弃对象</td><td style="text-align:center">dealloc</td><td style="text-align:center">-</td></tr></tbody></table><h2 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h2><ul><li>ARC 是苹果引入的一种自动内存管理机制，会根据引用计数自动监视对象的生存周期，实现方式是在编译时期自动在已有代码中插入合适的内存管理代码以及在 Runtime 做一些优化。</li><li>在ARC中与内存管理有关的变量标识符，有下面几种：<ul><li><code>__strong</code></li><li><code>__weak</code></li><li><code>__unsafe_unretained</code></li><li><code>__autoreleasing</code></li></ul></li><li><code>__strong</code> 是默认使用的标识符。只有还有一个强指针指向某个对象，这个对象就会一直存活。</li><li><code>__weak</code> 声明这个引用不会保持被引用对象的存活，如果对象没有强引用了，弱引用会被置为 nil。</li><li><code>__unsafe_unretained</code> 声明这个引用不会保持被引用对象的存活，如果对象没有强引用了，它不会被置为 nil。如果它引用的对象被回收掉了，该指针就变成了野指针。</li><li><code>__autoreleasing</code> 用于标示使用引用传值的参数（id *），在函数返回时会被自动释放掉。</li><li>或者可以用属性标识符，前面的博客有提到</li></ul><h2 id="Autorelease-Pool"><a href="#Autorelease-Pool" class="headerlink" title="Autorelease Pool"></a>Autorelease Pool</h2><ul><li><p>在 ARC 下，我们并不需要手动调用 autorelease 有关的方法，甚至可以完全不知道 autorelease 的存在，就可以正确管理好内存。因为 Cocoa Touch 的 Runloop 中，每个 runloop circle 中系统都自动加入了 Autorelease Pool 的创建和释放。</p></li><li><p>当我们需要创建和销毁大量的对象时，使用手动创建的 autoreleasepool 可以有效的避免内存峰值的出现。因为如果不手动创建的话，外层系统创建的 pool 会在整个 runloop circle 结束之后才进行 drain，手动创建的话，会在 block 结束之后就进行 drain 操作。一个普遍被使用的例子如下：</p><pre><code class="hljs objectivec"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000000</span>; i++)&#123;    <span class="hljs-keyword">@autoreleasepool</span>    &#123;        <span class="hljs-built_in">NSString</span>* string = <span class="hljs-string">@"ab c"</span>;        <span class="hljs-built_in">NSArray</span>* array = [string componentsSeparatedByString:string];    &#125;&#125;</code></pre><p>如果不使用 autoreleasepool ，需要在循环结束之后释放 100000000 个字符串，如果 使用的话，则会在每次循环结束的时候都进行 release 操作。</p></li></ul>]]></content:encoded>
      
      
      
      
      <comments>http://yoursite.com/2019/10/20/Objective-C%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Objective-C中的Block</title>
      <link>http://yoursite.com/2019/10/19/Objective-C%E4%B8%AD%E7%9A%84Block/</link>
      <guid>http://yoursite.com/2019/10/19/Objective-C%E4%B8%AD%E7%9A%84Block/</guid>
      <pubDate>Sat, 19 Oct 2019 15:07:59 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;Block的定义&quot;&gt;&lt;a href=&quot;#Block的定义&quot; class=&quot;headerlink&quot; title=&quot;Block的定义&quot;&gt;&lt;/a&gt;Block的定义&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一种匿名函数，语法如下：&lt;/li&gt;
&lt;li&gt;&lt;code&gt;return_type </description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="Block的定义"><a href="#Block的定义" class="headerlink" title="Block的定义"></a>Block的定义</h2><ul><li>一种匿名函数，语法如下：</li><li><code>return_type (^block_name)(parameters)</code></li><li><strong>注意</strong>：Block是一种OC对象；当Block作为函数参数时应该放在参数列表的最后一个</li></ul><h2 id="多种场景下的Block语法"><a href="#多种场景下的Block语法" class="headerlink" title="多种场景下的Block语法"></a>多种场景下的Block语法</h2><ol><li><p>作为变量</p><p><code>returnType (^blockName)(parameterTypes) = ^returnType(parameters) {...};</code></p></li><li><p>作为属性</p><p><code>@property (nonatomic, copy) returnType (^blockName)(parameterTypes);</code></p></li><li><p>函数中的参数</p><p><code>- (void)someMethodThatTakesABlock:(returnType (^)(parameterTypes))blockName;</code></p></li><li><p>调用函数时的参数</p><p><code>[someObject someMethodThatTakesABlock:^returnType (parameters) {...}];</code></p></li><li><p>作为typedef</p><pre><code class="hljs objectivec"><span class="hljs-keyword">typedef</span> returnType (^TypeName)(parameterTypes);TypeName blockName = ^returnType(parameters) &#123;...&#125;;</code></pre></li></ol><h2 id="为何Block内的self要弱引用？"><a href="#为何Block内的self要弱引用？" class="headerlink" title="为何Block内的self要弱引用？"></a>为何Block内的self要弱引用？</h2><ul><li><p>在非 ARC 的情况下，对于 block 类型的属性应该使用 <code>copy</code> ，因为 block 需要维持其作用域中捕获的变量。在 ARC 中编译器会自动对 block 进行 copy 操作，因此使用 <code>strong</code> 或者 <code>copy</code> 都可以，没有什么区别，但是苹果仍然建议使用 <code>copy</code> 来指明编译器的行为。</p></li><li><p>lock 在捕获外部变量的时候，会保持一个强引用，当在 block 中捕获 <code>self</code> 时，由于对象会对 block 进行 <code>copy</code>，于是便形成了强引用循环：</p></li><li><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">BlockKeeper</span> : <span class="hljs-title">NSObject</span></span><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">copy</span>) <span class="hljs-keyword">void</span> (^block)(<span class="hljs-keyword">void</span>);<span class="hljs-keyword">@end</span></code></pre><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">BlockKeeper</span></span>- (<span class="hljs-keyword">void</span>)configureBlock &#123;    <span class="hljs-keyword">self</span>.block = ^&#123;        [<span class="hljs-keyword">self</span> doSomething];    <span class="hljs-comment">// capturing a strong reference to self</span>                               <span class="hljs-comment">// creates a strong reference cycle</span>    &#125;;&#125;...<span class="hljs-keyword">@end</span></code></pre></li><li><p>为了避免强引用循环，最好对self弱引用：</p><pre><code class="hljs objectivec">- (<span class="hljs-keyword">void</span>)configureBlock &#123;    BlockKeeper * __<span class="hljs-keyword">weak</span> weakSelf = <span class="hljs-keyword">self</span>;    <span class="hljs-keyword">self</span>.block = ^&#123;        [weakSelf doSomething];   <span class="hljs-comment">// capture the weak reference</span>                                  <span class="hljs-comment">// to avoid the reference cycle</span>    &#125;&#125;</code></pre></li><li><p>使用弱引用会带来另一个问题，<code>weakSelf</code> 有可能会为 nil，如果多次调用 <code>weakSelf</code> 的方法，有可能在 block 执行过程中 <code>weakSelf</code> 变为 nil。因此需要在 block 中将 <code>weakSelf</code> “强化“</p></li><li><pre><code class="hljs objectivec">__<span class="hljs-keyword">weak</span> __typeof__(<span class="hljs-keyword">self</span>) weakSelf = <span class="hljs-keyword">self</span>;<span class="hljs-built_in">NSBlockOperation</span> *op = [[[<span class="hljs-built_in">NSBlockOperation</span> alloc] init] autorelease];[ op addExecutionBlock:^ &#123;    __<span class="hljs-keyword">strong</span> __typeof__(<span class="hljs-keyword">self</span>) strongSelf = weakSelf;    [strongSelf doSomething];    [strongSelf doMoreThing];&#125; ];[someOperationQueue addOperation:op];__<span class="hljs-keyword">strong</span>` 这一句在执行的时候，如果 WeakSelf 还没有变成 <span class="hljs-literal">nil</span>，那么就会 <span class="hljs-keyword">retain</span> <span class="hljs-keyword">self</span>，让 <span class="hljs-keyword">self</span> 在 block 执行期间不会变为 <span class="hljs-literal">nil</span>。这样上面的 `doSomething` 和 `doMoreThing` 要么全执行成功，要么全失败，不会出现一个成功一个失败，即执行到中间 `<span class="hljs-keyword">self</span>` 变成 <span class="hljs-literal">nil</span> 的情况。</code></pre></li><li><p><code>__strong</code> 这一句在执行的时候，如果 WeakSelf 还没有变成 nil，那么就会 retain self，让 self 在 block 执行期间不会变为 nil。这样上面的 <code>doSomething</code> 和 <code>doMoreThing</code> 要么全执行成功，要么全失败，不会出现一个成功一个失败，即执行到中间 <code>self</code> 变成 nil 的情况。</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://hit-alibaba.github.io/interview/iOS/ObjC-Basic/Block.html" target="_blank" rel="noopener">https://hit-alibaba.github.io/interview/iOS/ObjC-Basic/Block.html</a></li></ul>]]></content:encoded>
      
      
      
      
      <comments>http://yoursite.com/2019/10/19/Objective-C%E4%B8%AD%E7%9A%84Block/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
