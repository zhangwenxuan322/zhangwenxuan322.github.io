<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Man in the middle</title>
      <link href="/2020/09/22/Man-in-the-middle/"/>
      <url>/2020/09/22/Man-in-the-middle/</url>
      
        <content type="html"><![CDATA[<h2 id="Mitm"><a href="#Mitm" class="headerlink" title="Mitm"></a>Mitm</h2><p>“中间人”在网络世界有独特的意义，他可以做好事也可以做坏事，但在本文只单纯的谈论技术本身。</p><blockquote><p><strong>中间人攻击</strong>（英语：<strong>M</strong>an-<strong>i</strong>n-<strong>t</strong>he-<strong>m</strong>iddle attack，缩写：<strong>MITM</strong>）在<a href="https://zh.wikipedia.org/wiki/密码学" target="_blank" rel="noopener">密码学</a>和<a href="https://zh.wikipedia.org/wiki/计算机安全" target="_blank" rel="noopener">计算机安全</a>领域中是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。在许多情况下这是很简单的（例如，在一个未加密的<a href="https://zh.wikipedia.org/wiki/Wi-Fi" target="_blank" rel="noopener">Wi-Fi</a> <a href="https://zh.wikipedia.org/wiki/无线接入点" target="_blank" rel="noopener">无线接入点</a>的接受范围内的中间人攻击者，可以将自己作为一个中间人插入这个网络）。</p></blockquote><h2 id="HTTP与HTTPS"><a href="#HTTP与HTTPS" class="headerlink" title="HTTP与HTTPS"></a>HTTP与HTTPS</h2><p>在谈论中间人攻击之前需要简单地讲解一下 HTTP 协议与 HTTPS 协议：</p><ol><li><p>HTTP 协议</p><p>Hyper Text Transfer Protocol，超文本传输协议。它基于 TCP/IP 通讯协议来传递数据，通过 TCP 请求，三次握手建立连接之后发送 HTTP 请求并接收 HTTP 响应。</p><p><img src="https://www.concurrency.com/getattachment/baa462c8-ac8e-49af-91ce-bc37e4234f31/http.png.aspx?lang=en-US" srcset="/img/loading.gif" alt="HTTP 协议的请求流程" title="HTTP 协议的请求流程"></p><p>它的请求报文和响应报文都由状态行、状态头以及正文组成：</p><p><img src="https://mdn.mozillademos.org/files/13687/HTTP_Request.png" srcset="/img/loading.gif" alt="报文" title="报文"></p><p>但 HTTP 协议存在信息明文传输的问题，这样可能导致请求内容被篡改、冒名顶替使用者等问题，通过抓包可以清楚的看到请求具体信息，存在安全隐患。</p><p><img src="https://portswigger.net/web-security/images/http-request-smuggling.svg" srcset="/img/loading.gif" alt="抓包" title="抓包"></p></li><li><p>HTTPS 协议</p><p>为了解决 HTTP 协议中存在的问题，HTTPS 横空出世。HTTPS = HTTP + SSL/TLS (HyperText Transfer Protocol over Secure Socket Layer)，借助 SSL 证书来验证服务器的身份，并且为浏览器和服务器之间的通信进行加密。</p><p><em>SSL(Secure Socket Layer，安全套接字层)</em>：1994年为 Netscape 所研发，SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。</p><p><em>TLS(Transport Layer Security，传输层安全)</em>：其前身是 SSL，它最初的几个版本（SSL 1.0、SSL 2.0、SSL 3.0）由网景公司开发，1999年从 3.1 开始被 IETF 标准化并改名，发展至今已经有 TLS 1.0、TLS 1.1、TLS 1.2 三个版本。SSL3.0和TLS1.0由于存在安全漏洞，已经很少被使用到。TLS 1.3 改动会比较大，目前还在草案阶段，目前使用最广泛的是TLS 1.1、TLS 1.2。</p><p><img src="https://sniffer-site.oss-cn-shenzhen.aliyuncs.com/HTTPS_Process.png" srcset="/img/loading.gif" alt="HTTPS 协议流程" title="HTTPS流程"></p><ol><li>首先客户端通过URL访问服务器建立SSL连接。</li><li>服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端。</li><li>客户端的服务器开始协商SSL连接的安全等级，也就是信息加密的等级。</li><li>客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</li><li>服务器利用自己的私钥解密出会话密钥。</li><li>服务器利用会话密钥加密与客户端之间的通信。</li></ol><p>简而言之，就是用 HTTPS 协议的网站你没办法简单地抓包看到请求内容了。</p></li></ol><h2 id="拦截-HTTPS-请求内容"><a href="#拦截-HTTPS-请求内容" class="headerlink" title="拦截 HTTPS 请求内容"></a>拦截 HTTPS 请求内容</h2><p>由于 HTTPS 协议是用非对称加密算法，所以暴力解密几乎不可能。但即使这样安全的加解密流程下也存在漏洞，中间人劫持的流程如下：</p><ul><li>你和服务器之间有一台邪恶的路由器M</li><li>当你给HTTPS网站的服务器发请求后，网站带着公钥P响应你</li><li>响应到达M，M拿到了P，但是并不把它交给你，而是自己伪造了一对公私钥MP和MS，并把MP给你</li><li>你拿到MP，以为是网站的公钥P，用它加密了S，再请求网站</li><li>请求到达M，M使用MS解开S，再用P加密S交给网站</li></ul><p><img src="https://hackernoon.com/drafts/sh1g3wdt.png" srcset="/img/loading.gif" alt="MITM" title="MITM"></p><p>如果想在 Mac 上实践一下可以借助自带的 Keychain Access 软件生成一个被自己系统信任的 CA 证书，然后借助 Surge 等软件可以做到本机的 HTTPS 抓包。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB" target="_blank" rel="noopener">维基百科MITM</a></li><li><a href="http://scm.zoomquiet.top/data/20161106124704/index.html" target="_blank" rel="noopener">Surge MitM 证书的创建和配置</a></li><li><a href="https://zhuanlan.zhihu.com/p/72616216" target="_blank" rel="noopener">HTTP与HTTPS</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Internet </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何突破macOS的文件安全权限限制</title>
      <link href="/2020/09/10/%E5%A6%82%E4%BD%95%E7%AA%81%E7%A0%B4macOS%E7%9A%84%E6%96%87%E4%BB%B6%E5%AE%89%E5%85%A8%E6%9D%83%E9%99%90%E9%99%90%E5%88%B6/"/>
      <url>/2020/09/10/%E5%A6%82%E4%BD%95%E7%AA%81%E7%A0%B4macOS%E7%9A%84%E6%96%87%E4%BB%B6%E5%AE%89%E5%85%A8%E6%9D%83%E9%99%90%E9%99%90%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>今天在尝试用Python连接Oracle数据库时遇到一个报错：</p><pre><code class="hljs undefined">cx_Oracle.DatabaseError: DPI-1047: Cannot locate a 64-bit Oracle<span class="hljs-built_in"> Client </span>library: <span class="hljs-string">"dlopen(libclntsh.dylib, 1): no suitable image found.</span></code></pre><p>大致是需要一个64位的Oracle客户端，而我的Mac上没有，那么解决方案也很简单，去下一个就好，为了轻便选择了Instant Oracle（instantclient-basiclite-macos.x64-19.3.0.0.0dbru.zip）<a href="https://www.oracle.com/database/technologies/instant-client/macos-intel-x86-downloads.html" target="_blank" rel="noopener">下载地址</a>。然后遵循如下操作即可完成轻量Oracle客户端的安装：</p><ol><li><p>创建文件夹，并将压缩包解压到这个文件夹下</p><pre><code class="hljs undefined">sudo mkdir -p /opt/oraclesudp cp instantclient-basic-macos.x64<span class="hljs-number">-19.3</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>dbru.zip /opt/oracle/（如果当前在下载文件所在目录下）cd /opt/oracle/sudo unzip instantclient-basic-macos.x64<span class="hljs-number">-19.3</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>dbru.zip</code></pre></li><li><p>创建超链接，以使应用程序能够找到该库</p><pre><code class="hljs undefined">mkdir ~<span class="hljs-regexp">/libln -s /opt</span><span class="hljs-regexp">/oracle/instantclient</span>_19_3/libclntsh.dylib ~<span class="hljs-regexp">/lib/</span></code></pre></li></ol><p>到此应该再执行Python的数据读取程序就可以成功了，但是他出现了：（当时没截图，从网上找的，版本号不太对但不影响）</p><p><img src="/2020/09/10/如何突破macOS的文件安全权限限制/security.png" srcset="/img/loading.gif" alt="security"></p><p>这也没吓住我，去系统设置的安全项里给他解封了就好，但是我解封之后仍然遇到同样的错误，这就一时摸不着头脑了。</p><p>Google了一番，发现<a href="http://oraontap.blogspot.com/2020/01/mac-os-x-catalina-and-oracle-instant.html" target="_blank" rel="noopener">这篇文章</a>，通过<code>ls -lg@</code>命令，我们可以得到以下：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ls -lg@</span>total 484136-r-xr-xr-x@ 1 staff       5780 Feb 22  2019 BASIC_LICENSE com.apple.quarantine        57 -rw-r--r--@ 1 staff       1670 Aug 19 05:57 BASIC_README com.apple.quarantine        57 -r-xr-xr-x@ 1 staff       5780 Feb 22  2019 SQLPLUS_LICENSE com.apple.quarantine        57 -rw-r--r--@ 1 staff       1676 Sep  6 04:11 SQLPLUS_README com.apple.quarantine        57 -rwxr-xr-x@ 1 staff       9888 Aug 19 05:57 adrci com.apple.quarantine        57 -rwxr-xr-x@ 1 staff      40368 Aug 19 05:57 genezi com.apple.quarantine        57 -r-xr-xr-x@ 1 staff        342 Apr 24  2015 glogin.sql com.apple.quarantine        57 lrwxrwxrwx  1 staff         20 Jan 16 08:39 libclntsh.dylib -&gt; libclntsh.dylib.19.1lrwxrwxrwx  1 staff         20 Jan 16 08:39 libclntsh.dylib.10.1 -&gt; libclntsh.dylib.19.1lrwxrwxrwx  1 staff         20 Jan 16 08:39 libclntsh.dylib.11.1 -&gt; libclntsh.dylib.19.1lrwxrwxrwx  1 staff         20 Jan 16 08:39 libclntsh.dylib.12.1 -&gt; libclntsh.dylib.19.1lrwxrwxrwx  1 staff         20 Jan 16 08:39 libclntsh.dylib.18.1 -&gt; libclntsh.dylib.19.1-rwxr-xr-x@ 1 staff   98137256 Aug 13 02:10 libclntsh.dylib.19.1 com.apple.quarantine        57 -rwxr-xr-x@ 1 staff    4803832 Jul  7  2019 libclntshcore.dylib.19.1 com.apple.quarantine        57 -rwxr-xr-x@ 1 staff    8349944 Aug  6 12:14 libnnz19.dylib com.apple.quarantine        57 lrwxrwxrwx  1 staff         18 Jan 16 08:39 libocci.dylib -&gt; libocci.dylib.19.1lrwxrwxrwx  1 staff         18 Jan 16 08:39 libocci.dylib.10.1 -&gt; libocci.dylib.19.1lrwxrwxrwx  1 staff         18 Jan 16 08:39 libocci.dylib.11.1 -&gt; libocci.dylib.19.1lrwxrwxrwx  1 staff         18 Jan 16 08:39 libocci.dylib.12.1 -&gt; libocci.dylib.19.1lrwxrwxrwx  1 staff         18 Jan 16 08:39 libocci.dylib.18.1 -&gt; libocci.dylib.19.1-rwxr-xr-x@ 1 staff    1594048 Jul  5  2019 libocci.dylib.19.1 com.apple.quarantine        57 -rwxr-xr-x@ 1 staff  125518764 Aug 19 05:57 libociei.dylib com.apple.quarantine        57 -r-xr-xr-x@ 1 staff     151980 Jul  3  2019 libocijdbc19.dylib com.apple.quarantine        57 -rwxr-xr-x@ 1 staff     100492 Aug 13 02:32 liboramysql19.dylib com.apple.quarantine        57 -rwxrwxrwx@ 1 staff    1322588 Sep  6 04:05 libsqlplus.dylib com.apple.quarantine        57 -r-xr-xr-x@ 1 staff    1659868 Jul  5  2019 libsqlplusic.dylib com.apple.quarantine        57 drwxr-xr-x@ 3 staff         96 Aug 19 05:57 network com.apple.quarantine        57 -rw-r--r--@ 1 staff    4210510 May 10  2019 ojdbc8.jar com.apple.quarantine        57 -rwxr-xr-x@ 1 staff       8528 Sep  6 04:11 sqlplus com.apple.quarantine        57 -rw-r--r--@ 1 staff    1680080 May 10  2019 ucp.jar com.apple.quarantine        57 -rwxr-xr-x@ 1 staff     150080 Aug 19 05:57 uidrvci com.apple.quarantine        57 -rw-r--r--@ 1 staff      74263 Apr 16  2019 xstreams.jar com.apple.quarantine        57</code></pre><p>这里不难看出macOS通过文件上的<code>com.apple.quarantine</code>标签来判断该文件是否应该被过滤，简单的解决方法就是把这些标签删掉，<em>注意！！：执行以下操作前请务必判断程序无问题，不然会给Mac带来感染病毒的风险</em></p><ol><li><p>先给所有文件写权限，因为有些文件没有该权限：</p><pre><code class="hljs undefined"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> instantclient_19_3</span><span class="hljs-meta">$</span><span class="bash"> sudo chmod u+w *</span></code></pre></li><li><p>删除<code>com.apple.quarantine</code>标签：</p><pre><code class="hljs undefined"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> ..</span><span class="hljs-meta">$</span><span class="bash"> xattr -r -d -s com.apple.quarantine instantclient_19_3</span></code></pre></li></ol><p>这只是一种应用场景，实际上可以应用在更多被隔离的<strong>安全软件</strong>上，使用之前请先权衡，安全第一位。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vim搭建python环境</title>
      <link href="/2020/09/08/vim%E6%90%AD%E5%BB%BApython%E7%8E%AF%E5%A2%83/"/>
      <url>/2020/09/08/vim%E6%90%AD%E5%BB%BApython%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<ul><li><p>Vim和Python3</p><p>如果用的是macOS，并且是系统自带的Vim，那么它默认是不支持Python3的，可以通过<code>vim --version | grep python</code>查看。</p><p>那么首先就是要安装一个支持Python3的Vim，这里brew提供了支持，通过brew安装的Vim默认支持Python3，安装语句<code>brew install vim</code>。同时Mac自带的是Python2，所以还需要安装Python3，安装语句<code>brew install python3</code>。为了能让系统调用到我们后来通过brew安装的Vim和Python3，需要修改系统环境变量加载顺序:</p><ol><li><code>sudo vim /etc/paths</code></li><li>调整顺序，将<code>/usr/local/bin</code>调至第一顺位</li><li>重启终端</li><li>完成上述操作后即可用which命令查看调用的vim和python3来源。</li></ol></li><li><p>Mac上Vim中内容复制到其他程序</p><p>在.vimrc中配置：<code>set clipboard=unnamed</code></p></li><li><p>Vim中直接运行Python文件</p><p>在.vimrc中配置如下内容：</p><pre><code class="hljs sh"><span class="hljs-string">" Python相关filetype plugin on"</span> 按 F5 执行当前 Python 代码<span class="hljs-string">"map &lt;F5&gt; :call PRUN()&lt;CR&gt;func! PRUN()    exec "</span>w<span class="hljs-string">"    if &amp;filetype == 'python'        exec "</span>!python3 %<span class="hljs-string">"    endifendfunc</span></code></pre></li><li><p>Vim插件</p><p>推荐使用vim-plug进行Vim的插件管理，安装步骤如下：</p><pre><code class="hljs shell">mkdir ~/.vim/autoload/cd ~/.vim/autoload/wget https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</code></pre><p><a href="https://raw.githubusercontent.com的域名被DNS污染了，被解析成无效IP，需要挂代理。" target="_blank" rel="noopener">https://raw.githubusercontent.com的域名被DNS污染了，被解析成无效IP，需要挂代理。</a></p><p>安装完成后只需要在.vimrc中将插件写在如下代码块中：</p><pre><code class="hljs sh">call plug<span class="hljs-comment">#begin('~/.vim/plugged')</span><span class="hljs-string">"插件写在这里"</span><span class="hljs-string">"Plug 'xxx/xxx' 格式像这样"</span> call plug<span class="hljs-comment">#end()</span></code></pre><p>保存后执行<code>:PlugInstall</code>即可自动安装插件</p></li><li><p>关于jedi-vim插件无法联想第三方库文件的问题</p><p>这个问题真是困扰了我一个下午，查找了很多资料，本来以为是macOS的问题，结果看到官方的一个<a href="https://github.com/davidhalter/jedi/issues/1188" target="_blank" rel="noopener">issue</a>上面提到jedi-vim还不支持Python3.7的第三方库查询，但是这个issue是两年前提出的并且作者说会在4-5个月内完成，不知道为什么还不支持：）。不过如果按照我上面的操作是不会遇到这个问题的，因为brew默认安装Python3.8，我之前用的是Python3.7。</p></li><li><p>其他的好用插件</p><ol><li>indentLine：<code>Plug &#39;Yggdroot/indentLine&#39;</code>缩进指示器，<code>:IndentLinesToggle</code>开启或关闭</li><li>autopep8：<code>Plug &#39;tell-k/vim-autopep8&#39;</code>代码格式化，<code>:Autopep8</code>运行</li><li>vim-flake8：<code>pip3 install flake8</code> -&gt; <code>Plug &#39;nvie/vim-flake8&#39;</code>代码检查，F7调用</li><li>auto-pairs：<code>Plug &#39;jiangmiao/auto-pairs&#39;</code>自动补齐括号</li><li>nerdcommenter：<code>Plug &#39;preservim/nerdcommenter&#39;</code>快捷注释，<code>\cc</code>注释，<code>\cu</code>反注释，前面可以加行数，默认是一行</li></ol></li></ul><h3 id="Vim光标操作"><a href="#Vim光标操作" class="headerlink" title="Vim光标操作"></a>Vim光标操作</h3><p>这里再列举一些常用的光标快捷操作，加以练习就能烂熟于心：</p><ul><li>w 向前移动一个单词，b 向后移动一个单词，e 移动到下一个单词的词尾，ge 移动到上一个单词的词尾</li><li>gg 移动到文件头，G 移动到文件尾，$ 移动到行头，^ 移动到行尾</li><li>y 复制指定范围内的内容，如要复制全文：ggyG</li><li>:行数，可前往指定行</li><li>dw 从指定位置删到下个单词开头，daw 删除光标所在的单词，dd 删除整行</li><li>u 撤销操作，在.vimrc中配置<code>nnoremap U &lt;C-r&gt;</code>可得到 U 反撤销的操作</li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>git commit提交关键字整理</title>
      <link href="/2020/08/17/git-commit%E6%8F%90%E4%BA%A4%E5%85%B3%E9%94%AE%E5%AD%97%E6%95%B4%E7%90%86/"/>
      <url>/2020/08/17/git-commit%E6%8F%90%E4%BA%A4%E5%85%B3%E9%94%AE%E5%AD%97%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>看到了阿里技术微信公众号的关于<code>git commit</code>规范的建议文章，在此做一下个人习惯上的整理</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>团队开发中，富有个性的提交信息往往会引起同事们的理解困难，更不要说中英混杂、缩写、笼统概括等问题。个人观点：中文团队中提交信息以中文为主，除非专业术语等不便于翻译的词汇用英文；大家都能接受的缩写可以写，避免独创缩写；信息要写详细，如修复了某一问题不要单纯的写<code>fix bug</code>这样模棱两可的文字，要具体到问题。</p><h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><p>按照阿里技术的介绍，提交信息的格式应该如下：</p><p><code>&lt;type&gt;(&lt;scope&gt;):&lt;subject&gt;</code></p><ul><li><p>type(必须)</p><p>提交类别，包含以下几种类型：</p><ol><li>feat: 新功能的添加，feature的前四个字母；</li><li>fix/to: 修复bug（fix:最终完成时使用，to:修复过程中的多次提交使用）</li><li>docs: 文档</li><li>style: 格式，不影响代码运行的变动</li><li>refactor: 重构</li><li>perf: 优化</li><li>test: 测试</li><li>chore: 辅助工具的开发</li><li>revert: 回滚版本</li><li>merge: 代码合并</li><li>sync: 同步主线或分支</li></ol></li><li><p>scope(可选)</p><p>变动影响的范围，根据架构方式不同而不同。</p></li><li><p>subject(必须)</p><p>对于提交的描述，不超过50个字符，根据团队选择语言，句尾不加标点。</p></li></ul><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><pre><code class="hljs undefined"><span class="hljs-function"><span class="hljs-title">refactor</span><span class="hljs-params">(Converter)</span></span>:重构聚合操作<span class="hljs-function"><span class="hljs-title">docs</span><span class="hljs-params">(README)</span></span>:添加README文档</code></pre><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>规范的提交信息便于项目历史追溯，可以格式化提交信息进行日志分析。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>个人配置记录</title>
      <link href="/2020/05/29/%E4%B8%AA%E4%BA%BA%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/05/29/%E4%B8%AA%E4%BA%BA%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="zshrc"><a href="#zshrc" class="headerlink" title=".zshrc"></a>.zshrc</h1><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> If you come from bash you might have to change your <span class="hljs-variable">$PATH</span>.</span><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$HOME</span>/bin:/usr/<span class="hljs-built_in">local</span>/bin:<span class="hljs-variable">$PATH</span></span><span class="hljs-meta">#</span><span class="bash"> Path to your oh-my-zsh installation.</span>export ZSH="/Users/zhangwenxuan/.oh-my-zsh"export LANG=en_US.UTF-8<span class="hljs-meta">#</span><span class="bash"> Set name of the theme to load --- <span class="hljs-keyword">if</span> <span class="hljs-built_in">set</span> to <span class="hljs-string">"random"</span>, it will</span><span class="hljs-meta">#</span><span class="bash"> load a random theme each time oh-my-zsh is loaded, <span class="hljs-keyword">in</span> <span class="hljs-built_in">which</span> <span class="hljs-keyword">case</span>,</span><span class="hljs-meta">#</span><span class="bash"> to know <span class="hljs-built_in">which</span> specific one was loaded, run: <span class="hljs-built_in">echo</span> <span class="hljs-variable">$RANDOM_THEME</span></span><span class="hljs-meta">#</span><span class="bash"> See https://github.com/robbyrussell/oh-my-zsh/wiki/Themes</span>ZSH_THEME="ys"<span class="hljs-meta">#</span><span class="bash"> Set list of themes to pick from when loading at random</span><span class="hljs-meta">#</span><span class="bash"> Setting this variable when ZSH_THEME=random will cause zsh to load</span><span class="hljs-meta">#</span><span class="bash"> a theme from this variable instead of looking <span class="hljs-keyword">in</span> ~/.oh-my-zsh/themes/</span><span class="hljs-meta">#</span><span class="bash"> If <span class="hljs-built_in">set</span> to an empty array, this variable will have no effect.</span><span class="hljs-meta">#</span><span class="bash"> ZSH_THEME_RANDOM_CANDIDATES=( <span class="hljs-string">"robbyrussell"</span> <span class="hljs-string">"agnoster"</span> )</span><span class="hljs-meta">#</span><span class="bash"> Uncomment the following line to use <span class="hljs-keyword">case</span>-sensitive completion.</span><span class="hljs-meta">#</span><span class="bash"> CASE_SENSITIVE=<span class="hljs-string">"true"</span></span><span class="hljs-meta">#</span><span class="bash"> Uncomment the following line to use hyphen-insensitive completion.</span><span class="hljs-meta">#</span><span class="bash"> Case-sensitive completion must be off. _ and - will be interchangeable.</span><span class="hljs-meta">#</span><span class="bash"> HYPHEN_INSENSITIVE=<span class="hljs-string">"true"</span></span><span class="hljs-meta">#</span><span class="bash"> Uncomment the following line to <span class="hljs-built_in">disable</span> bi-weekly auto-update checks.</span>DISABLE_AUTO_UPDATE="true"<span class="hljs-meta">#</span><span class="bash"> Uncomment the following line to automatically update without prompting.</span><span class="hljs-meta">#</span><span class="bash"> DISABLE_UPDATE_PROMPT=<span class="hljs-string">"true"</span></span><span class="hljs-meta">#</span><span class="bash"> Uncomment the following line to change how often to auto-update (<span class="hljs-keyword">in</span> days).</span><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">export</span> UPDATE_ZSH_DAYS=13</span><span class="hljs-meta">#</span><span class="bash"> Uncomment the following line <span class="hljs-keyword">if</span> pasting URLs and other text is messed up.</span><span class="hljs-meta">#</span><span class="bash"> DISABLE_MAGIC_FUNCTIONS=<span class="hljs-literal">true</span></span><span class="hljs-meta">#</span><span class="bash"> Uncomment the following line to <span class="hljs-built_in">disable</span> colors <span class="hljs-keyword">in</span> ls.</span><span class="hljs-meta">#</span><span class="bash"> DISABLE_LS_COLORS=<span class="hljs-string">"true"</span></span><span class="hljs-meta">#</span><span class="bash"> Uncomment the following line to <span class="hljs-built_in">disable</span> auto-setting terminal title.</span><span class="hljs-meta">#</span><span class="bash"> DISABLE_AUTO_TITLE=<span class="hljs-string">"true"</span></span><span class="hljs-meta">#</span><span class="bash"> Uncomment the following line to <span class="hljs-built_in">enable</span> <span class="hljs-built_in">command</span> auto-correction.</span><span class="hljs-meta">#</span><span class="bash"> ENABLE_CORRECTION=<span class="hljs-string">"true"</span></span><span class="hljs-meta">#</span><span class="bash"> Uncomment the following line to display red dots whilst waiting <span class="hljs-keyword">for</span> completion.</span><span class="hljs-meta">#</span><span class="bash"> COMPLETION_WAITING_DOTS=<span class="hljs-string">"true"</span></span><span class="hljs-meta">#</span><span class="bash"> Uncomment the following line <span class="hljs-keyword">if</span> you want to <span class="hljs-built_in">disable</span> marking untracked files</span><span class="hljs-meta">#</span><span class="bash"> under VCS as dirty. This makes repository status check <span class="hljs-keyword">for</span> large repositories</span><span class="hljs-meta">#</span><span class="bash"> much, much faster.</span><span class="hljs-meta">#</span><span class="bash"> DISABLE_UNTRACKED_FILES_DIRTY=<span class="hljs-string">"true"</span></span><span class="hljs-meta">#</span><span class="bash"> Uncomment the following line <span class="hljs-keyword">if</span> you want to change the <span class="hljs-built_in">command</span> execution time</span><span class="hljs-meta">#</span><span class="bash"> stamp shown <span class="hljs-keyword">in</span> the <span class="hljs-built_in">history</span> <span class="hljs-built_in">command</span> output.</span><span class="hljs-meta">#</span><span class="bash"> You can <span class="hljs-built_in">set</span> one of the optional three formats:</span><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-string">"mm/dd/yyyy"</span>|<span class="hljs-string">"dd.mm.yyyy"</span>|<span class="hljs-string">"yyyy-mm-dd"</span></span><span class="hljs-meta">#</span><span class="bash"> or <span class="hljs-built_in">set</span> a custom format using the strftime <span class="hljs-keyword">function</span> format specifications,</span><span class="hljs-meta">#</span><span class="bash"> see <span class="hljs-string">'man strftime'</span> <span class="hljs-keyword">for</span> details.</span><span class="hljs-meta">#</span><span class="bash"> HIST_STAMPS=<span class="hljs-string">"mm/dd/yyyy"</span></span><span class="hljs-meta">#</span><span class="bash"> Would you like to use another custom folder than <span class="hljs-variable">$ZSH</span>/custom?</span><span class="hljs-meta">#</span><span class="bash"> ZSH_CUSTOM=/path/to/new-custom-folder</span><span class="hljs-meta">#</span><span class="bash"> Which plugins would you like to load?</span><span class="hljs-meta">#</span><span class="bash"> Standard plugins can be found <span class="hljs-keyword">in</span> ~/.oh-my-zsh/plugins/*</span><span class="hljs-meta">#</span><span class="bash"> Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/</span><span class="hljs-meta">#</span><span class="bash"> Example format: plugins=(rails git textmate ruby lighthouse)</span><span class="hljs-meta">#</span><span class="bash"> Add wisely, as too many plugins slow down shell startup.</span>plugins=(git zsh-autosuggestions)<span class="hljs-meta">#</span><span class="bash"> plugin settings</span>bindkey '\t' autosuggest-acceptsource $ZSH/oh-my-zsh.sh<span class="hljs-meta">#</span><span class="bash"> User configuration</span><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">source</span> ~/.bash_profile</span><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">export</span> MANPATH=<span class="hljs-string">"/usr/local/man:<span class="hljs-variable">$MANPATH</span>"</span></span><span class="hljs-meta">#</span><span class="bash"> You may need to manually <span class="hljs-built_in">set</span> your language environment</span><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">export</span> LANG=en_US.UTF-8</span><span class="hljs-meta">#</span><span class="bash"> Preferred editor <span class="hljs-keyword">for</span> <span class="hljs-built_in">local</span> and remote sessions</span><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-keyword">if</span> [[ -n <span class="hljs-variable">$SSH_CONNECTION</span> ]]; <span class="hljs-keyword">then</span></span><span class="hljs-meta">#</span><span class="bash">   <span class="hljs-built_in">export</span> EDITOR=<span class="hljs-string">'vim'</span></span><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-keyword">else</span></span><span class="hljs-meta">#</span><span class="bash">   <span class="hljs-built_in">export</span> EDITOR=<span class="hljs-string">'mvim'</span></span><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-keyword">fi</span></span><span class="hljs-meta">#</span><span class="bash"> Compilation flags</span><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">export</span> ARCHFLAGS=<span class="hljs-string">"-arch x86_64"</span></span><span class="hljs-meta">#</span><span class="bash"> Set personal aliases, overriding those provided by oh-my-zsh libs,</span><span class="hljs-meta">#</span><span class="bash"> plugins, and themes. Aliases can be placed here, though oh-my-zsh</span><span class="hljs-meta">#</span><span class="bash"> users are encouraged to define aliases within the ZSH_CUSTOM folder.</span><span class="hljs-meta">#</span><span class="bash"> For a full list of active aliases, run `<span class="hljs-built_in">alias</span>`.</span><span class="hljs-meta">#</span><span class="bash"></span><span class="hljs-meta">#</span><span class="bash"> Example aliases</span><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">alias</span> zshconfig=<span class="hljs-string">"mate ~/.zshrc"</span></span><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">alias</span> ohmyzsh=<span class="hljs-string">"mate ~/.oh-my-zsh"</span></span><span class="hljs-meta">#</span><span class="bash"> Maven</span>export M2_HOME=/Users/zhangwenxuan/apache-maven-3.3.9export PATH=$PATH:$M2_HOME/bin</code></pre><h1 id="vimrc"><a href="#vimrc" class="headerlink" title=".vimrc"></a>.vimrc</h1><pre><code class="hljs shell">" Configuration file for vimset modelines=0" CVE-2007-2438" Normally we use vim-extensions. If you want true vi-compatibility" remove change the following statementsset nocompatible" Use Vim defaults instead of 100% vi compatibilityset backspace=2" more powerful backspacing" Don't write backup file if vim is being called by "crontab -e"au BufWrite /private/tmp/crontab.* set nowritebackup nobackup" Don't write backup file if vim is being called by "chpass"au BufWrite /private/etc/pw.* set nowritebackup nobackuplet skip_defaults_vim=1" 开启语法高亮syntax onset nu!" 提示当前模式set showmode" 开启鼠标操作set mouse=a" 开启256色set t_Co=256" 开启文件类型检查filetype indent on" 开启自动缩进set autoindent" 光标所在行高亮set cursorline" 不会在单词内折行set wrap" 垂直滚动光标距离底部的距离set scrolloff=5" 显示光标当前位置set ruler" 自动匹配括号set showmatch" 搜索时高亮提示set hlsearch" 搜索时每输入一个字母就回到第一个匹配内容set incsearch" 搜索时忽略大小写set ignorecase" 开启文件监视set autoread" 设置Vim窗口标题set title" 快捷键映射" 以下为Vim的常用操作简化" 取消撤销操作nnoremap U &lt;C-r&gt;</code></pre><h1 id="etc-motd"><a href="#etc-motd" class="headerlink" title="/etc/motd"></a>/etc/motd</h1><p>进入终端的提示文字，修改需要sudo</p><pre><code class="hljs undefined">You have <span class="hljs-keyword">no</span> responsibility <span class="hljs-keyword">to</span> live <span class="hljs-keyword">up</span> <span class="hljs-keyword">to</span> what other people think you ought <span class="hljs-keyword">to</span> accomplish. I have <span class="hljs-keyword">no</span> responsibility <span class="hljs-keyword">to</span> <span class="hljs-keyword">be</span> like they expect <span class="hljs-keyword">me</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">be</span>. It<span class="hljs-string">'s their mistake, not my failing.</span></code></pre>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>大数据历史发展以及未来架构路线</title>
      <link href="/2020/05/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%8E%86%E5%8F%B2%E5%8F%91%E5%B1%95%E4%BB%A5%E5%8F%8A%E6%9C%AA%E6%9D%A5%E6%9E%B6%E6%9E%84%E8%B7%AF%E7%BA%BF/"/>
      <url>/2020/05/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%8E%86%E5%8F%B2%E5%8F%91%E5%B1%95%E4%BB%A5%E5%8F%8A%E6%9C%AA%E6%9D%A5%E6%9E%B6%E6%9E%84%E8%B7%AF%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="大数据历史"><a href="#大数据历史" class="headerlink" title="大数据历史"></a>大数据历史</h1><ul><li><p>2004年</p><p>Google的三篇论文为大数据发展打下基础，这三篇论文分别为：</p><ol><li>分布式文件系统GFS</li><li>大数据分布式计算框架MapReduce</li><li>NoSQL类型数据库BigTable</li></ol></li><li><p>2006年</p><p>Doug Cutting启动了一个赫赫有名的项目：Hadoop，主要包括Hadoop分布式文件系统HDFS和大数据计算引擎MapReduce，分别实现了GFS和MapReduce其中两篇论文</p></li><li><p>2007年</p><p>HBase诞生，实现了三篇论文中的最后一篇BigTable</p></li><li><p>2008年</p><p>出现了Pig、Hive等支持使用SQL语法来进行大数据计算，极大的降低了Hadoop的使用难度，数据分析师和工程师可以无门槛的对大数据进行数据分析和处理</p></li><li><p>2012年</p><p>Hadoop将执行引擎和资源调度分离出来，成立了Yarn资源调度系统，这年Spark也开始崭露头角，逐步替代MapReduce在企业应用中的地位</p></li></ul><h1 id="大数据架构"><a href="#大数据架构" class="headerlink" title="大数据架构"></a>大数据架构</h1><p>首先需要明确的是什么样的项目需要使用到大数据解决方案。如果数据只是GB级的项目，数据源单一的项目，并没有必要使用大数据解决方案。只有数据量达到TB或者PB并且数据有持续大量增加的可能性并且有多个数据源的情况下，才有必要使用大数据。</p><center class="half"><br><img src="/2020/05/29/大数据历史发展以及未来架构路线/Big Data Archtecture.png" srcset="/img/loading.gif"><br></center><p>上图简单划分了大数据的架构设计，主要分为以下几层：</p><ol><li><p>数据来源层(Sources Layer)</p><p>该架构的设计在很大程度上取决于数据源。这些数据是从许多不同格式的数据来源获取的，这些来源包括关系型数据库，企业服务器和传感器，如物联网设备，第三方数据提供商等，这些数据既可以是批量数据也可以是实时数据。</p></li><li><p>数据注入层(Data Ingestion Layer)</p><p>这是大数据开始旅程的第一层。该层将数据进行归类整理并传输给之后的层次。一般来说，这一层的数据可以通过像Kafka这样的消息队列或者是通过REST Api的形式进行传递。</p></li><li><p>存储层(Storage Layer)</p><p>这一层是大数据的接收端，它用在最合适的方式接收各种数据源，并将其存储。该层甚至可以根据系统的要求改变数据的格式。例如，批处理数据通常存储在分布式文件存储系统诸如HDFS等，在另一方面，结构化数据只能使用RDBMS来存储，这一切都取决于数据的格式。</p></li><li><p>分析层(Analysis Layer)</p><p>采用大数据的公司的唯一目标就是从数据中获得洞察力，从而进行数据驱动的决策。为了使用户分析大数据，在大数据架构中最重要的一层是分析层。这层与存储层交互，该架构需要多种工具来分析大数据。结构化数据是很容易处理的，而分析非结构化数据需要进行一些先进的工具。</p></li><li><p>批处理(Batch Processing)</p><p>由于数据量非常大，该架构需要一个批式处理系统去过滤、聚合以及处理数据以便于高级分析。这些都是长期运行的批处理作业，涉及到从存储层读取数据、处理、最后写入输出到新文件，批处理目前主要采用Spark来解决。</p></li><li><p>流处理(Real-Time Processing)</p><p>处理实时数据是在大数据世界里最热的潮流。流处理需要有一个系统来捕捉和存储实时数据，目前最好的解决方案是Flink，并且在未来Flink有代替Spark做批处理作业的趋势。</p></li><li><p>商业分析层(BI Layer)</p><p>这一层对接收到的最终数据进行分析，主要由人来进行决策。</p></li></ol><h1 id="大数据未来发展"><a href="#大数据未来发展" class="headerlink" title="大数据未来发展"></a>大数据未来发展</h1><p>大数据发展的十多年来，数据一直呈现成倍上涨并且没有放缓的趋势。这些数据的聚集主要是通过互联网，包括社交网络，网页搜索请求，文本消息和媒体文件。数据的另一巨大份额是通过物联网装置和传感器获取的。这些数据的大量增长带动了经济发展，根据Statista的调查，这部分经济增长已经达到了490亿美元。</p><p>对于未来大数据方向有以下预测：</p><ol><li>数据量将继续增加，并且数据将向云迁移</li><li>机器学习将会在大数据领域中越来越重要</li><li>数据科学家将在高需求</li><li>隐私仍将是一个热点问题</li><li>流处理将占据主导地位</li></ol><p>就我所在的公司而言，目前也有将大数据批处理引擎从Spark迁移到Flink的趋势，Flink发展迅速，在短时间内就成为了Apache基金会下的顶级项目，再加上背后有大公司对开源社区的支持，Flink无疑是未来更好的选择。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><p>大数据历史</p><p><a href="https://www.cnblogs.com/chenqionghe/p/11375295.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenqionghe/p/11375295.html</a></p></li><li><p>大数据架构</p><p><a href="https://towardsdatascience.com/big-data-architecture-the-art-of-handling-big-data-bc565c3a7295" target="_blank" rel="noopener">https://towardsdatascience.com/big-data-architecture-the-art-of-handling-big-data-bc565c3a7295</a></p></li><li><p>大数据未来发展</p><p><a href="https://www.itransition.com/blog/the-future-of-big-data" target="_blank" rel="noopener">https://www.itransition.com/blog/the-future-of-big-data</a></p></li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>项目打包到阿里云运行并停止的流程</title>
      <link href="/2020/05/20/%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91%E8%BF%90%E8%A1%8C%E5%B9%B6%E5%81%9C%E6%AD%A2%E7%9A%84%E6%B5%81%E7%A8%8B/"/>
      <url>/2020/05/20/%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91%E8%BF%90%E8%A1%8C%E5%B9%B6%E5%81%9C%E6%AD%A2%E7%9A%84%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<center class="half"><br><img src="/2020/05/20/项目打包到阿里云运行并停止的流程/项目打包到阿里云运行并停止的流程.png" srcset="/img/loading.gif"><br></center><h2 id="附上数据科学地铁线路图"><a href="#附上数据科学地铁线路图" class="headerlink" title="附上数据科学地铁线路图"></a>附上数据科学地铁线路图</h2><center class="half"><br><img src="/2020/05/20/项目打包到阿里云运行并停止的流程/metro.jpg" srcset="/img/loading.gif"><br></center>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Spark中的TSUDAF</title>
      <link href="/2020/04/02/Spark%E4%B8%AD%E7%9A%84TSUDAF/"/>
      <url>/2020/04/02/Spark%E4%B8%AD%E7%9A%84TSUDAF/</url>
      
        <content type="html"><![CDATA[<h1 id="类型安全的用户自定义聚合函数（Type-Safe-User-Defined-Aggregate-Functions）"><a href="#类型安全的用户自定义聚合函数（Type-Safe-User-Defined-Aggregate-Functions）" class="headerlink" title="类型安全的用户自定义聚合函数（Type-Safe User-Defined Aggregate Functions）"></a>类型安全的用户自定义聚合函数（Type-Safe User-Defined Aggregate Functions）</h1><h2 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h2><p>Itemdata.data</p><pre><code class="hljs undefined"><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">11</span>,<span class="hljs-number">4.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">32</span>,<span class="hljs-number">1.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">176</span>,<span class="hljs-number">27.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">183</span>,<span class="hljs-number">11.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">184</span>,<span class="hljs-number">5.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">207</span>,<span class="hljs-number">9.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">256</span>,<span class="hljs-number">3.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">258</span>,<span class="hljs-number">4.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">259</span>,<span class="hljs-number">16.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">260</span>,<span class="hljs-number">8.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">261</span>,<span class="hljs-number">18.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">301</span>,<span class="hljs-number">1.0</span></code></pre><p>实现类型安全的用户自定义聚合函数需要集成org.apache.spark.sql.expressions.Aggregator的Aggregator[K,V,C]抽象类，并且实现该类的6个函数。</p><h2 id="zero"><a href="#zero" class="headerlink" title="zero"></a>zero</h2><p>zero相当于UDAF中的initialize初始化函数，初始化存储中间数据的Average</p><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><p>reduce函数相当于UDAF中的update函数，当有新的数据a时，更新中间数据b。</p><h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><p>同UDAF中的merge</p><h2 id="finish"><a href="#finish" class="headerlink" title="finish"></a>finish</h2><p>同UDAF中的evaluate</p><h2 id="bufferEncoder"><a href="#bufferEncoder" class="headerlink" title="bufferEncoder"></a>bufferEncoder</h2><p>缓冲数据编码方式</p><h2 id="outputEncoder"><a href="#outputEncoder" class="headerlink" title="outputEncoder"></a>outputEncoder</h2><p>结果数据输出的编码方式</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><pre><code class="hljs scala"><span class="hljs-keyword">import</span> org.apache.spark.sql.&#123;<span class="hljs-type">Encoder</span>, <span class="hljs-type">Encoders</span>, <span class="hljs-type">SparkSession</span>&#125;<span class="hljs-keyword">import</span> org.apache.spark.sql.expressions.<span class="hljs-type">Aggregator</span><span class="hljs-comment">/** * 类型安全的自定义算子聚合测试类 */</span><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">TSUDAFTest</span> </span>&#123;  <span class="hljs-comment">// 映射数据</span>  <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Data</span>(<span class="hljs-params">user_id: <span class="hljs-type">String</span>, item_id: <span class="hljs-type">String</span>, score: <span class="hljs-type">Double</span></span>)</span>  <span class="hljs-comment">// 注意声明为var，因为要进行计算</span>  <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Average</span>(<span class="hljs-params">var sum: <span class="hljs-type">Double</span>, var count: <span class="hljs-type">Long</span></span>)</span>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTSUDAF</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Aggregator</span>[<span class="hljs-type">Data</span>, <span class="hljs-type">Average</span>, <span class="hljs-type">Double</span>] </span>&#123;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">zero</span></span>: <span class="hljs-type">Average</span> = <span class="hljs-type">Average</span>(<span class="hljs-number">0.0</span>D, <span class="hljs-number">0</span>L)    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reduce</span></span>(b: <span class="hljs-type">Average</span>, a: <span class="hljs-type">Data</span>): <span class="hljs-type">Average</span> = &#123;      b.sum += a.score      b.count += <span class="hljs-number">1</span>L      b    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge</span></span>(b1: <span class="hljs-type">Average</span>, b2: <span class="hljs-type">Average</span>): <span class="hljs-type">Average</span> = &#123;      b1.sum += b2.sum      b1.count += b2.count      b1    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">finish</span></span>(reduction: <span class="hljs-type">Average</span>): <span class="hljs-type">Double</span> = reduction.sum / reduction.count    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bufferEncoder</span></span>: <span class="hljs-type">Encoder</span>[<span class="hljs-type">Average</span>] = <span class="hljs-type">Encoders</span>.product    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">outputEncoder</span></span>: <span class="hljs-type">Encoder</span>[<span class="hljs-type">Double</span>] = <span class="hljs-type">Encoders</span>.scalaDouble  &#125;  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;    <span class="hljs-keyword">val</span> spark = <span class="hljs-type">SparkSession</span>.builder()      .master(<span class="hljs-string">"local"</span>)      .appName(<span class="hljs-string">"TSUDAF-Test"</span>)      .getOrCreate()    <span class="hljs-keyword">val</span> rdd = spark.sparkContext.textFile(<span class="hljs-string">"itemdata.data"</span>)    <span class="hljs-keyword">import</span> spark.implicits._    <span class="hljs-keyword">val</span> ds = rdd.map(_.split(<span class="hljs-string">","</span>)).map(d =&gt; <span class="hljs-type">Data</span>(d(<span class="hljs-number">0</span>), d(<span class="hljs-number">1</span>), d(<span class="hljs-number">2</span>).toDouble)).toDS()    <span class="hljs-keyword">val</span> avg = <span class="hljs-keyword">new</span> <span class="hljs-type">MyTSUDAF</span>().toColumn.name(<span class="hljs-string">"avg_score"</span>)    ds.select(avg).show()  &#125;&#125;</code></pre><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><pre><code class="hljs undefined"><span class="hljs-code">+----------------+</span><span class="hljs-section">|       avg_score|+----------------+</span>|8.76923076923077|<span class="hljs-code">+----------------+</span>s</code></pre>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Spark中的UDAF</title>
      <link href="/2020/04/02/Spark%E4%B8%AD%E7%9A%84UDAF/"/>
      <url>/2020/04/02/Spark%E4%B8%AD%E7%9A%84UDAF/</url>
      
        <content type="html"><![CDATA[<h1 id="无类型的用户自定于聚合函数（Untyped-User-Defined-Aggregate-Functions）"><a href="#无类型的用户自定于聚合函数（Untyped-User-Defined-Aggregate-Functions）" class="headerlink" title="无类型的用户自定于聚合函数（Untyped User-Defined Aggregate Functions）"></a>无类型的用户自定于聚合函数（Untyped User-Defined Aggregate Functions）</h1><h2 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h2><p>Itemdata.data</p><pre><code class="hljs undefined"><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">11</span>,<span class="hljs-number">4.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">32</span>,<span class="hljs-number">1.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">176</span>,<span class="hljs-number">27.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">183</span>,<span class="hljs-number">11.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">184</span>,<span class="hljs-number">5.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">207</span>,<span class="hljs-number">9.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">256</span>,<span class="hljs-number">3.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">258</span>,<span class="hljs-number">4.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">259</span>,<span class="hljs-number">16.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">260</span>,<span class="hljs-number">8.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">261</span>,<span class="hljs-number">18.0</span><span class="hljs-number">0162381440670851711</span>,<span class="hljs-number">301</span>,<span class="hljs-number">1.0</span></code></pre><p>无类型的用户自定于聚合函数需要继承抽象类UserDefinedAggregateFunction，并重写该类的8个函数</p><h2 id="inputSchema"><a href="#inputSchema" class="headerlink" title="inputSchema"></a>inputSchema</h2><p> 定义输入数据的Schema，要求类型是StructType，它的参数是由StructField类型构成的数组。</p><h2 id="bufferSchema"><a href="#bufferSchema" class="headerlink" title="bufferSchema"></a>bufferSchema</h2><p>计算平均数需要用到总和sum和总个数count，bufferSchema用来接收中间计算数据。</p><h2 id="dataType"><a href="#dataType" class="headerlink" title="dataType"></a>dataType</h2><p>申明返回值的类型</p><h2 id="deterministic"><a href="#deterministic" class="headerlink" title="deterministic"></a>deterministic</h2><p>对输入数据进行一致性检验，是一个布尔值，当为true时，表示对于同样的输入会得到同样的输出。</p><h2 id="initialize"><a href="#initialize" class="headerlink" title="initialize"></a>initialize</h2><p>初始化缓存数据。比如score的缓存数据有两个：sum和count，需要初始化为sum=0.0和count=0L。</p><h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><p>更新缓存变量。比如这里当有新的score输入时，需要将它的值更新变量sum中，并将count加1。</p><h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><p>将更新的缓存变量存入到缓存中。</p><h2 id="evaluate"><a href="#evaluate" class="headerlink" title="evaluate"></a>evaluate</h2><p>用于计算我们的最终结果。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><pre><code class="hljs scala"><span class="hljs-keyword">import</span> org.apache.spark.sql.&#123;<span class="hljs-type">Row</span>, <span class="hljs-type">SparkSession</span>&#125;<span class="hljs-keyword">import</span> org.apache.spark.sql.expressions.&#123;<span class="hljs-type">MutableAggregationBuffer</span>, <span class="hljs-type">UserDefinedAggregateFunction</span>&#125;<span class="hljs-keyword">import</span> org.apache.spark.sql.types.&#123;<span class="hljs-type">DataType</span>, <span class="hljs-type">DoubleType</span>, <span class="hljs-type">LongType</span>, <span class="hljs-type">StructField</span>, <span class="hljs-type">StructType</span>&#125;<span class="hljs-comment">/** * 自定义算子测试类 */</span><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">UDAFTest</span> </span>&#123;  <span class="hljs-comment">/**   * 计算平均score   */</span>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyUDAF</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">UserDefinedAggregateFunction</span> </span>&#123;    <span class="hljs-comment">/**     * 计算平均score，输入的应该是score这一列数据     * StructField定义了列字段的名称score_column,字段的类型Double     * StructType要求输入数StructField构成的数组Array，这里只有一列，所以与Nil运算生成Array     * @return StructType     */</span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inputSchema</span></span>: <span class="hljs-type">StructType</span> =      <span class="hljs-type">StructType</span>(        <span class="hljs-type">StructField</span>(<span class="hljs-string">"score_column"</span>, <span class="hljs-type">DoubleType</span>) ::          <span class="hljs-type">Nil</span>)    <span class="hljs-comment">/**     * 缓存Schema，存储中间计算结果，     * 比如计算平均score,需要计算score的总和和score的个数,然后average(score)=sum(score)/count(score)     * 所以这里定义了StructType类型：两个StructField字段：sum和count     * @return StructType     */</span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bufferSchema</span></span>: <span class="hljs-type">StructType</span> =      <span class="hljs-type">StructType</span>(        <span class="hljs-type">StructField</span>(<span class="hljs-string">"sum"</span>, <span class="hljs-type">DoubleType</span>) ::        <span class="hljs-type">StructField</span>(<span class="hljs-string">"count"</span>, <span class="hljs-type">LongType</span>) ::        <span class="hljs-type">Nil</span>)    <span class="hljs-comment">/**     * 自定义集成算子最终返回的数据类型     * 也就是average(score)的类型，所以是Double     * @return DataType 返回数据类型     */</span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dataType</span></span>: <span class="hljs-type">DataType</span> = <span class="hljs-type">DoubleType</span>    <span class="hljs-comment">/**     * 数据一致性检验：对于同样的输入，输出是一样的     * @return Boolean true 同样的输入，输出也一样     */</span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deterministic</span></span>: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">true</span>    <span class="hljs-comment">/**     * 初始化缓存sum和count     * sum=0.0，count=0     * @param buffer 中间数据     */</span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span></span>(buffer: <span class="hljs-type">MutableAggregationBuffer</span>): <span class="hljs-type">Unit</span> = &#123;      buffer(<span class="hljs-number">0</span>) = <span class="hljs-number">0.0</span>      buffer(<span class="hljs-number">1</span>) = <span class="hljs-number">0</span>L    &#125;    <span class="hljs-comment">/**     * 每次计算更新缓存     * @param buffer 缓存数据     * @param input 输入数据score     */</span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update</span></span>(buffer: <span class="hljs-type">MutableAggregationBuffer</span>, input: <span class="hljs-type">Row</span>): <span class="hljs-type">Unit</span> = &#123;      <span class="hljs-keyword">if</span> (!input.isNullAt(<span class="hljs-number">0</span>)) &#123;        buffer(<span class="hljs-number">0</span>) = buffer.getDouble(<span class="hljs-number">0</span>) + input.getDouble(<span class="hljs-number">0</span>)        buffer(<span class="hljs-number">1</span>) = buffer.getLong(<span class="hljs-number">1</span>) + <span class="hljs-number">1</span>      &#125;    &#125;    <span class="hljs-comment">/**     * 将更新后的buffer存储到缓存     * @param buffer1 缓存     * @param buffer2 更新后的buffer     */</span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge</span></span>(buffer1: <span class="hljs-type">MutableAggregationBuffer</span>, buffer2: <span class="hljs-type">Row</span>): <span class="hljs-type">Unit</span> = &#123;      buffer1(<span class="hljs-number">0</span>) = buffer1.getDouble(<span class="hljs-number">0</span>) + buffer2.getDouble(<span class="hljs-number">0</span>)      buffer1(<span class="hljs-number">1</span>) = buffer1.getLong(<span class="hljs-number">1</span>) + buffer2.getLong(<span class="hljs-number">1</span>)    &#125;    <span class="hljs-comment">/**     * 计算最终的结果：average(score)=sum(score)/count(score)     * @param buffer     * @return     */</span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">evaluate</span></span>(buffer: <span class="hljs-type">Row</span>): <span class="hljs-type">Any</span> =      buffer.getDouble(<span class="hljs-number">0</span>) / buffer.getLong(<span class="hljs-number">1</span>)  &#125;  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;    <span class="hljs-keyword">val</span> spark = <span class="hljs-type">SparkSession</span>.builder()      .master(<span class="hljs-string">"local"</span>)      .appName(<span class="hljs-string">"UDAF-Test"</span>)      .getOrCreate()    spark.udf.register(<span class="hljs-string">"myUDAF"</span>, <span class="hljs-keyword">new</span> <span class="hljs-type">MyUDAF</span>)    <span class="hljs-keyword">val</span> df = spark.read.csv(<span class="hljs-string">"itemdata.data"</span>).toDF(<span class="hljs-string">"user_id"</span>, <span class="hljs-string">"item_id"</span>, <span class="hljs-string">"score"</span>)    df.createOrReplaceTempView(<span class="hljs-string">"data"</span>)    spark.sql(<span class="hljs-string">"select myUDAF(score) as avg_score from data"</span>).show()  &#125;&#125;</code></pre><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><pre><code class="hljs undefined"><span class="hljs-code">+----------------+</span><span class="hljs-section">|       avg_score|+----------------+</span><span class="hljs-section">|8.76923076923077|+----------------+</span></code></pre>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>SparkSQL</title>
      <link href="/2020/04/01/SparkSQL/"/>
      <url>/2020/04/01/SparkSQL/</url>
      
        <content type="html"><![CDATA[<h1 id="Spark-SQL"><a href="#Spark-SQL" class="headerlink" title="Spark SQL"></a>Spark SQL</h1><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><center class="half"><br><img src="/2020/04/01/SparkSQL/架构图.jpg" srcset="/img/loading.gif"><br></center><p><strong>语言API</strong></p><p>Spark与不同的语言和Spark SQL兼容。 它也是由这些语言支持的API（python，scala，java，HiveQL）。</p><p><strong>模式RDD</strong></p><p>Spark Core是使用称为RDD的特殊数据结构设计的。 通常，Spark SQL适用于模式，表和记录。 因此，我们可以使用Schema RDD作为临时表。 我们可以将此Schema RDD称为数据帧。</p><p><strong>数据源</strong></p><p>通常spark-core的数据源是文本文件，Avro文件等。但是，Spark SQL的数据源不同。 这些是Parquet文件，JSON文档，HIVE表和Cassandra数据库。</p><h1 id="Spark-SQL的特点"><a href="#Spark-SQL的特点" class="headerlink" title="Spark SQL的特点"></a>Spark SQL的特点</h1><ol><li>容易集成</li><li>统一的数据访问方式</li><li>兼容Hive</li></ol><h1 id="DataFrame和DataSet"><a href="#DataFrame和DataSet" class="headerlink" title="DataFrame和DataSet"></a>DataFrame和DataSet</h1><ol><li><p>DataFrame</p><p>DataFrame是组织成命名列的<strong>数据集</strong>。它在概念上等同于关系数据库中的<strong>表</strong>，但在底层具有更丰富的优化。DataFrames可以从各种来源构建，</p><p>例如：</p><p>　　结构化数据文件</p><p>　　hive中的表</p><p>　　外部数据库或现有RDDs</p><p>DataFrame API支持的语言有Scala，Java，Python和R。</p><center class="half"><br><img src="/2020/04/01/SparkSQL/RDD和DataFrame.png" srcset="/img/loading.gif"><br></center><p>从上图可以看出，DataFrame多了数据的结构信息，<strong>即schema</strong>。RDD是分布式的 Java对象的集合。DataFrame是分布式的Row对象的集合。DataFrame除了提供了比RDD更丰富的算子以外，更重要的特点是提升执行效率、减少数据读取以及执行计划的优化。</p></li><li><p>DataSet</p><p>Dataset是数据的分布式集合。Dataset是在Spark 1.6中添加的一个新接口，是DataFrame之上更高一级的抽象。它提供了RDD的优点（强类型化，使用强大的lambda函数的能力）以及Spark SQL优化后的执行引擎的优点。一个Dataset 可以从JVM对象构造，然后使用函数转换（map， flatMap，filter等）去操作。 Dataset API 支持Scala和Java。 Python不支持Dataset API。</p></li></ol><h1 id="主要介绍一下DataSet"><a href="#主要介绍一下DataSet" class="headerlink" title="主要介绍一下DataSet"></a>主要介绍一下DataSet</h1><p>Dataset是一个分布式的数据收集器。这是在Spark1.6之后新加的一个接口，兼顾了RDD的优点（<strong>强类型</strong>，可以使用功能强大的lambda）以及Spark SQL的执行器高效性的优点。所以可以把DataFrames看成是一种特殊的Datasets，即：Dataset(Row)</p><center class="half"><br><img src="/2020/04/01/SparkSQL/DataSet.png" srcset="/img/loading.gif"><br></center><p><strong>创建DataSet，方式一：使用序列</strong></p><ol><li><p>定义case class</p><p><code>case class MyData(a:Int,b:String)</code></p></li><li><p>生成序列，并创建DataSet</p><p><code>val ds = Seq(MyData(1,&quot;Tom&quot;),MyData(2,&quot;Mary&quot;)).toDS</code></p></li><li><p>查看结果<br><img src="https://img2018.cnblogs.com/blog/1367933/201810/1367933-20181025100740657-1854671955.png" srcset="/img/loading.gif" alt="img"></p></li></ol><p><strong>创建DataSet，方式二：使用JSON数据</strong></p><ol><li>定义case class</li></ol><p>​       <code>case class Person(name: String, gender: String)</code></p><ol start="2"><li>通过JSON数据生成DataFrame</li></ol><p>​       <code>val df = spark.read.json(sc.parallelize(&quot;&quot;&quot;{&quot;gender&quot;: &quot;Male&quot;, &quot;name&quot;: &quot;Tom&quot;}&quot;&quot;&quot; :: Nil))</code></p><ol start="3"><li>将DataFrame转成DataSet</li></ol><p>​       <code>df.as[Person].show</code></p><p>​        <code>df.as[Person].collect</code></p><p><strong>创建DataSet，方式三：使用HDFS数据</strong></p><ol><li>读取HDFS数据，并创建DataSet</li></ol><p>​        <code>val linesDS = spark.read.text(&quot;hdfs://hadoop111:9000/data/data.txt&quot;).as[String]</code> </p><ol start="2"><li>对DataSet进行操作：分词后，查询长度大于3的单词</li></ol><p>​        <code>val words = linesDS.flatMap(_.split(&quot; &quot;)).filter(_.length &gt; 3)</code></p><p>​        <code>words.show</code></p><p>​        <code>words.collect</code></p><ol start="3"><li>执行WordCount程序</li></ol><p>​       <code>val result = linesDS.flatMap(_.split(&quot; &quot;)).map((_,1)).groupByKey(x =&gt; x._1).count</code></p><p>​       <code>result.show</code></p><p>​       排序：<code>result.orderBy($&quot;value&quot;).show</code></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Spark中的RDD</title>
      <link href="/2020/03/31/Spark%E4%B8%AD%E7%9A%84RDD/"/>
      <url>/2020/03/31/Spark%E4%B8%AD%E7%9A%84RDD/</url>
      
        <content type="html"><![CDATA[<h1 id="Spark-RDD"><a href="#Spark-RDD" class="headerlink" title="Spark RDD"></a>Spark RDD</h1><p>Spark 的核心是建立在统一的抽象弹性分布式数据集（Resiliennt Distributed Datasets，RDD）之上的，这使得 Spark 的各个组件可以无缝地进行集成，能够在同一个应用程序中完成大数据处理。</p><h1 id="RDD概念"><a href="#RDD概念" class="headerlink" title="RDD概念"></a>RDD概念</h1><p>可以将 RDD 理解为一个分布式对象集合，本质上是一个只读的分区记录集合。每个 RDD 可以分成多个分区，每个分区就是一个数据集片段。一个 RDD 的不同分区可以保存到集群中的不同结点上，从而可以在集群中的不同结点上进行并行计算。</p><center class="half"><br><img src="/2020/03/31/Spark中的RDD/RDD运作图.jpg" srcset="/img/loading.gif"><br></center><p>RDD 具有容错机制，并且只读不能修改，可以执行确定的转换操作创建新的 RDD。具体来讲，RDD 具有以下几个属性。</p><ul><li>只读：不能修改，只能通过转换操作生成新的 RDD。</li><li>分布式：可以分布在多台机器上进行并行处理。</li><li>弹性：计算过程中内存不够时它会和磁盘进行数据交换。</li><li>基于内存：可以全部或部分缓存在内存中，在多次计算间重用。</li></ul><h1 id="RDD基本操作"><a href="#RDD基本操作" class="headerlink" title="RDD基本操作"></a>RDD基本操作</h1><p>RDD 的操作分为转化（Transformation）操作和行动（Action）操作。转化操作就是从一个 RDD 产生一个新的 RDD，而行动操作就是进行实际的计算。</p><p>RDD 的操作是惰性的，当 RDD 执行转化操作的时候，实际计算并没有被执行，只有当 RDD 执行行动操作时才会促发计算任务提交，从而执行相应的计算操作。</p><ol><li>构建操作</li></ol><ul><li><p>从内存里直接读取数据。</p><p><code>val rdd01 = sc.makeRDD(List(l,2,3,4,5,6))</code></p></li><li><p>从文件系统里读取数据，文件系统的种类很多，常见的就是 HDFS 及本地文件系统。</p><p><code>val rdd:RDD[String] == sc.textFile(“file://...txt”,1)</code></p></li></ul><ol start="2"><li><p>转换操作</p><center class="half"><br><img src="/2020/03/31/Spark中的RDD/RDD转换.PNG" srcset="/img/loading.gif"><br></center></li><li><p>行动操作</p><center class="half"><br><img src="/2020/03/31/Spark中的RDD/RDD行动.PNG" srcset="/img/loading.gif"><br></center></li></ol><h1 id="RDD和MapReduce的区别"><a href="#RDD和MapReduce的区别" class="headerlink" title="RDD和MapReduce的区别"></a>RDD和MapReduce的区别</h1><p>RDD的概念是为了更快和更高效地实现MapReduce操作</p><h2 id="MapReduce迭代运算"><a href="#MapReduce迭代运算" class="headerlink" title="MapReduce迭代运算"></a>MapReduce迭代运算</h2><p>在多阶段应用程序中跨多个计算重用中间结果。下图说明了当前框架如何工作，同时对MapReduce执行迭代操作。这会由于数据复制，磁盘I / O和序列化而招致大量开销，这使得系统变慢。</p><center class="half"><br><img src="/2020/03/31/Spark中的RDD/MapReduce迭代运算.jpg" srcset="/img/loading.gif"><br></center><h2 id="Spark-RDD迭代运算"><a href="#Spark-RDD迭代运算" class="headerlink" title="Spark RDD迭代运算"></a>Spark RDD迭代运算</h2><p>下图给出了Spark RDD的迭代操作。<strong>它将中间结果存储在分布式存储器中，而不是稳定存储（磁盘）</strong>，并使系统更快。<br>注意 - 如果分布式内存（RAM）不足以存储中间结果（JOB的状态），则它将这些结果存储在磁盘上</p><center class="half"><br><img src="/2020/03/31/Spark中的RDD/RDD迭代运算.jpg" srcset="/img/loading.gif"><br></center>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Hadoop学习笔记</title>
      <link href="/2020/03/31/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/03/31/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Hadoop简介"><a href="#Hadoop简介" class="headerlink" title="Hadoop简介"></a>Hadoop简介</h1><p>Hadoop可运行于一般的商用服务器上，具有高容错、高可靠性、高扩展性等特点。特别适合写一次，读多次的场景。</p><center class="half"><br><img src="/2020/03/31/Hadoop学习笔记/Hadoop架构.png" srcset="/img/loading.gif"><br></center><ul><li>HDFS：Hadoop Distributed File System 分布式文件存储系统</li><li>YARN：分布式资源管理</li><li>MapReduce：分布式计算</li><li>Others：利用YARN的资源管理功能实现其他的数据处理方式</li></ul><h1 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h1><p>Hadoop Distributed File System，分布式文件系统</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><center class="half"><br><img src="/2020/03/31/Hadoop学习笔记/HDFS架构.png" srcset="/img/loading.gif"><br></center><ul><li><p>Block数据块</p><ol><li>基本存储单位，一般大小为64M。</li><li>大文件会被拆分成一个个块，存储于不同的机器。如果文件小于Block大小，实际的空间为其文件的大小。</li><li>基本的读写单位，类似于磁盘的页，每次都是读写一个块。</li><li>每个块都会被复制到多台机器，默认复制三份。</li></ol></li><li><p>NameNode</p><ol><li>存储文件的metadata，运行时所有数据都保存到内存，整个HDFS可存储的文件数受限于NameNode的内存大小。</li><li>一个Block在NameNode中对应一条记录（一般一个block占用150字节），如果是大量的小文件，会消耗大量内存。同时map task的数量是由splits来决定的，所以用MapReduce处理大量的小文件时，就会产生过多的map task，线程管理开销将会增加作业时间。处理大量小文件的速度远远小于处理同等大小的大文件的速度。因此Hadoop建议存储大文件。</li><li>数据会定时保存到本地磁盘，但不保存block的位置信息，而是由DataNode注册时上报和运行时维护（NameNode中与DataNode相关的信息并不保存到NameNode的文件系统中，而是NameNode每次重启后，动态重建）。</li><li>NameNode失效则整个HDFS都失效了，所以要保证NameNode的可用性。</li></ol></li><li><p>Secondary NameNode</p><p>定时与NameNode进行同步（定期合并文件系统镜像和编辑日志，然后把合并后的传给NameNode，替换其镜像，并清空编辑日志，类似于CheckPoint机制），但NameNode失效后仍需要手工将其设置成主机。</p></li><li><p>DataNode</p><ol><li>保存具体的Block数据。</li><li>负责数据的读写操作和复制操作。</li><li>DataNode启动时会向NameNode报告当前存储的数据块信息，后续也会定时报告修改信息。</li><li>DataNode之间会进行通信，复制数据块，保证数据的冗余性。</li></ol></li></ul><h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><center class="half"><br><img src="/2020/03/31/Hadoop学习笔记/HDFS写文件.png" srcset="/img/loading.gif"><br></center><ol><li><p>客户端将文件写入本地磁盘的HDFS Client文件中</p></li><li><p>当临时文件大小达到一个block大小时，HDFS client通知NameNode，申请写入文件</p></li><li><p>NameNode在HDFS的文件系统中创建一个文件，并把该block id和要写入的DataNode的列表返回给客户端</p></li><li><p>客户端收到这些信息后，将临时文件写入DataNodes</p></li></ol><ul><li>4.1 客户端将文件内容写入第一个DataNode（一般以4kb为单位进行传输）</li><li>4.2 第一个DataNode接收后，将数据写入本地磁盘，同时也传输给第二个DataNode</li><li>4.3 依此类推到最后一个DataNode，数据在DataNode之间是通过pipeline的方式进行复制的</li><li>4.4 后面的DataNode接收完数据后，都会发送一个确认给前一个DataNode，最终第一个DataNode返回确认给客户端</li><li>4.5 当客户端接收到整个block的确认后，会向NameNode发送一个最终的确认信息</li><li>4.6 如果写入某个DataNode失败，数据会继续写入其他的DataNode。然后NameNode会找另外一个好的DataNode继续复制，以保证冗余性</li><li>4.7 每个block都会有一个校验码，并存放到独立的文件中，以便读的时候来验证其完整性</li></ul><ol start="5"><li>文件写完后（客户端关闭），NameNode提交文件（这时文件才可见，如果提交前，NameNode垮掉，那文件也就丢失了。fsync：只保证数据的信息写到NameNode上，但并不保证数据已经被写到DataNode中）</li></ol><h2 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h2><center class="half"><br><img src="/2020/03/31/Hadoop学习笔记/HDFS读文件.png" srcset="/img/loading.gif"><br></center><ol><li>客户端向NameNode发送读取请求</li><li>NameNode返回文件的所有block和这些block所在的DataNodes（包括复制节点）</li><li>客户端直接从DataNode中读取数据，如果该DataNode读取失败（DataNode失效或校验码不对），则从复制节点中读取（如果读取的数据就在本机，则直接读取，否则通过网络读取）</li></ol><h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><ol><li><p>DataNode可以失效</p><p>DataNode会定时发送心跳到NameNode。如果一段时间内NameNode没有收到DataNode的心跳消息，则认为其失效。此时NameNode就会将该节点的数据（从该节点的复制节点中获取）复制到另外的DataNode中。</p></li><li><p>数据可以毁坏</p><p>无论是写入时还是硬盘本身的问题，只要数据有问题（读取时通过校验码来检测），都可以通过其他的复制节点读取，同时还会再复制一份到健康的节点中。</p></li><li><p>NameNode不可靠</p></li></ol><h1 id="YARN"><a href="#YARN" class="headerlink" title="YARN"></a>YARN</h1><h2 id="旧MapReduce架构"><a href="#旧MapReduce架构" class="headerlink" title="旧MapReduce架构"></a>旧MapReduce架构</h2><center class="half"><br><img src="/2020/03/31/Hadoop学习笔记/旧MapReduce架构.jpg" srcset="/img/loading.gif"><br></center><ul><li>JobTracker：作业生命周期管理（调度作业任务、跟踪进度、为任务提供容错）。</li><li>TaskTracker：加载或关闭任务，定时报告任务状态。</li></ul><p><em>存在的问题：</em></p><ol><li>obTracker是MapReduce的集中处理点，存在单点故障。</li><li>JobTracker完成了太多的任务，造成了过多的资源消耗，当MapReduce job 非常多的时候，会造成很大的内存开销。这也是业界普遍总结出老Hadoop的MapReduce只能支持4000 节点主机的上限。</li><li>在TaskTracker端，以map/reduce task的数目作为资源的表示过于简单，没有考虑到cpu/ 内存的占用情况，如果两个大内存消耗的task被调度到了一块，很容易出现OOM（OutOfMemory）。</li><li>在TaskTracker端，把资源强制划分为map task slot和reduce task slot, 如果当系统中只有map task或者只有reduce task的时候，会造成资源的浪费，也就集群资源利用的问题。</li></ol><h2 id="YARN架构"><a href="#YARN架构" class="headerlink" title="YARN架构"></a>YARN架构</h2><center class="half"><br><img src="/2020/03/31/Hadoop学习笔记/YARN架构1.jpg" srcset="/img/loading.gif"><br><img src="/2020/03/31/Hadoop学习笔记/YARN架构2.jpg" srcset="/img/loading.gif"><br></center><p>YARN就是将JobTracker的职责进行拆分，将资源管理和任务调度监控拆分成独立#x7ACB;的进程：一个全局的资源管理和一个每个作业的管理（ApplicationMaster） ResourceManager和NodeManager提供了计算资源的分配和管理，而ApplicationMaster则完成应用程序的运行</p><ul><li><strong>ResourceManager:</strong> 全局资源管理和任务调度</li><li><strong>NodeManager:</strong> 单个节点的资源管理和监控</li><li><strong>ApplicationMaster:</strong> 单个作业的资源管理和任务监控</li><li><strong>Container:</strong> 资源申请的单位和任务运行的容器</li></ul><h1 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h1><p>一种分布式的计算方式指定一个Map（映#x5C04;）函数，用来把一组键值对映射成一组新的键值对，指定并发的Reduce（归约）函数，用来保证所有映射的键值对中的每一个共享相同的键组。</p><p><em>详细流程</em></p><center class="half"><br><img src="/2020/03/31/Hadoop学习笔记/mapreduce-process.png" srcset="/img/loading.gif"><br></center>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Https和Http的区别</title>
      <link href="/2020/02/27/Https%E5%92%8CHttp%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/02/27/Https%E5%92%8CHttp%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>昨天在做毕设开发安卓端，向个人服务器请求数据的时候，遇到了<code>CLEARTEXT communication to *** not permitted by network security policy</code>的问题。搜索后发现是谷歌对于新版的安卓系统限制了非加密的流量请求。</p><p>解决方法有两种：</p><ol><li>把所有的http请求全部改为https请求</li><li>在AndroidManifest.xml中配置<code>cleartextTrafficPermitted=&quot;true&quot;</code></li></ol><p>此前对Https只停留在比Http安全这个理解层面，今天进行一下全面了解并做记录</p><h1 id="Https是什么？"><a href="#Https是什么？" class="headerlink" title="Https是什么？"></a>Https是什么？</h1><p><strong>HTTPS=HTTP over SSL/TLS，也就是说，HTTPS 在传输层 TCP 和应用层 HTTP 之间，多走了一层 SSL/TLS。</strong></p><center class="half"><br><img src="/2020/02/27/Https和Http的区别/Https图解.jpeg" srcset="/img/loading.gif"><br></center><p>由上图可以看出，<strong>TLS/SSL 是 HTTPS 的核心</strong>。</p><center class="half"><br><img src="/2020/02/27/Https和Http的区别/SSL图解.jpeg" srcset="/img/loading.gif"><br></center><p><strong>SSL/TLS 协议作用在传输层和应用层之间，对应用层数据进行加密传输。</strong></p><h1 id="为什么Https更安全"><a href="#为什么Https更安全" class="headerlink" title="为什么Https更安全"></a>为什么Https更安全</h1><p>HTTP 1.1 版本存在一个很大的问题-<strong>明文传输（Plaintext/Clear Text）</strong>，这个问题在互联网时代的今天是致命的，一旦数据在公共网络中被第三方截获，其通信内容轻而易举地就被窃取了。而这个明文传输也是在谷歌新版安卓系统上默认被禁止了。</p><p>为了解决这个问题，Https出现，它有三大优势：</p><ol><li><strong>数据加密，防窃听</strong></li><li><strong>身份验证，防冒充</strong></li><li><strong>完整性校验，防篡改</strong></li></ol><h2 id="数据加密"><a href="#数据加密" class="headerlink" title="数据加密"></a>数据加密</h2><p>Https同时拥有对称加密和非对称加密。前者只有一把密钥做加解密；后者有两把密钥，公钥和私钥，互为加解密，公钥给对方，私钥自己用。</p><h2 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h2><p><strong>数字证书用于主体身份验证。</strong></p><p>在 Chrome 浏览器上点击地址栏的“锁”标记后会出现下拉框，接着点击“证书”即可看到通过 HTTPS 访问该服务器时的数字证书。</p><center class="half"><br><img src="/2020/02/27/Https和Http的区别/Https证书.png" srcset="/img/loading.gif"><br></center><p>一张完整的数字证书包括：</p><ul><li><p><strong>主体的必要信息：版本(version)、序列号(serialNumber)、签名算法(signatureAlgorithm)、颁发者(issuer)、有效期(validity)、使用者(subject)、公钥信息(subjectPublicKeyInfo)</strong></p></li><li><p><strong>主体的扩展信息(extension)：如密钥标识符、证书策略等</strong></p></li><li><p><strong>数字签名(signature)，也称指纹</strong></p></li><li><center class="half"><br><img src="/2020/02/27/Https和Http的区别/数字证书.jpeg" srcset="/img/loading.gif"><br></center></li></ul><h2 id="完整性校验"><a href="#完整性校验" class="headerlink" title="完整性校验"></a>完整性校验</h2><p><strong>哈希</strong>，键值对数据结构，通过哈希函数把一个空间映射到另一个空间。非常好用的一个工具，比如负载均衡的一致性哈希、密码学中用于信息加密或数据校验的各种哈希（SHA、MD5 等）、二维空间定位的 GeoHash、对象相似度的 SimHash 等等。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>算法-二分查找法</title>
      <link href="/2020/02/22/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/"/>
      <url>/2020/02/22/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>二分查找也称为折半查找，每次都能将查找区间减半，这种折半特性的算法时间复杂度为 O(logN)。</p><h1 id="关键"><a href="#关键" class="headerlink" title="关键"></a>关键</h1><p>计算中值<strong>m</strong>，有两种方式：</p><ul><li>m = (l + h) / 2</li><li>m = l + (h - l) / 2</li></ul><p>第一种方式 l + h 可能出现加法溢出的情况，推荐使用第二种</p><h1 id="正常实现方式"><a href="#正常实现方式" class="headerlink" title="正常实现方式"></a>正常实现方式</h1><pre><code class="hljs undefined">Input : [1,2,3,4,5]key : 3<span class="hljs-keyword">return</span> the index : 2</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> key)</span> </span>&#123;    <span class="hljs-comment">// l 最低位 h 最高位</span>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, h = nums.length - <span class="hljs-number">1</span>;    <span class="hljs-comment">// 进入二分查找循环体</span>    <span class="hljs-keyword">while</span> (l &lt;= h) &#123;        <span class="hljs-comment">// 计算中值</span>        <span class="hljs-keyword">int</span> m = l + (h - l) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span> (nums[m] == key) &#123;          <span class="hljs-comment">// m 个元素为查找值，返回结果</span>            <span class="hljs-keyword">return</span> m;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[m] &gt; key) &#123;          <span class="hljs-comment">// m 个元素大于查找值，h 移动到 m - 1</span>            h = m - <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// m 个元素小于查找值，l 移动到 m + 1</span>            l = m + <span class="hljs-number">1</span>;        &#125;    &#125;  <span class="hljs-comment">// 循环结束没有找到值，返回 -1 ，表示没有找到</span>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>RESTful的一些状态码记录</title>
      <link href="/2020/02/19/RESTful%E7%9A%84%E4%B8%80%E4%BA%9B%E7%8A%B6%E6%80%81%E7%A0%81%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/02/19/RESTful%E7%9A%84%E4%B8%80%E4%BA%9B%E7%8A%B6%E6%80%81%E7%A0%81%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>RESTFUL（<strong>Representational State Transfer</strong>）是一种网络应用程序的设计风格和开发方式，基于<a href="https://baike.baidu.com/item/HTTP/243074" target="_blank" rel="noopener">HTTP</a>，可以使用<a href="https://baike.baidu.com/item/XML/86251" target="_blank" rel="noopener">XML</a>格式定义或<a href="https://baike.baidu.com/item/JSON/2462549" target="_blank" rel="noopener">JSON</a>格式定义。RESTFUL适用于移动互联网厂商作为业务使能接口的场景，实现第三方<a href="https://baike.baidu.com/item/OTT/9960940" target="_blank" rel="noopener">OTT</a>调用移动网络资源的功能，动作类型为新增、变更、删除所调用资源。</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>RESTFUL特点包括：</p><ol><li><p>每一个URI代表1种资源；</p></li><li><p>客户端使用GET、POST、PUT、DELETE4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源；</p></li><li><p>通过操作资源的表现形式来操作资源；</p></li><li><p>资源的表现形式是XML或者JSON；</p></li><li><p>客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都必须包含理解请求所必需的信息。</p></li></ol><h1 id="四种操作对应的状态码"><a href="#四种操作对应的状态码" class="headerlink" title="四种操作对应的状态码"></a>四种操作对应的状态码</h1><h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><p>安全且幂等<br>获取表示<br>变更时获取表示（缓存） </p><table><thead><tr><th>状态码</th><th>解释</th></tr></thead><tbody><tr><td>200</td><td>（OK）表示已在响应中发出</td></tr><tr><td>204</td><td>（无内容） 资源有空表示</td></tr><tr><td>301</td><td>（Moved Permanently）资源的URI已被更新</td></tr><tr><td>303</td><td>（See Other）其他（如，负载均衡）</td></tr><tr><td>304</td><td>（not modified）资源未更改（缓存）</td></tr><tr><td>400</td><td>（bad request）指代坏请求（如，参数错误）</td></tr><tr><td>404</td><td>（not found）资源不存在</td></tr><tr><td>406</td><td>（not acceptable）服务端不支持所需表示</td></tr><tr><td>500</td><td>（internal server error）通用错误响应</td></tr><tr><td>503</td><td>（Service Unavailable）服务端当前无法处理请求</td></tr></tbody></table><h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><p>不安全且不幂等<br>使用服务端管理的（自动产生）的实例号创建资源<br>创建子资源<br>部分更新资源<br>如果没有被修改，则不过更新资源（乐观锁）</p><table><thead><tr><th>状态码</th><th>解释</th></tr></thead><tbody><tr><td>200</td><td>（OK）如果现有资源已被更改</td></tr><tr><td>201</td><td>（created）如果新资源被创建</td></tr><tr><td>202</td><td>（accepted）已接受处理请求但尚未完成（异步处理）</td></tr><tr><td>301</td><td>（Moved Permanently）资源的URI被更新</td></tr><tr><td>303</td><td>（See Other）其他（如，负载均衡）</td></tr><tr><td>400</td><td>（bad request）指代坏请求</td></tr><tr><td>404</td><td>（not found）资源不存在</td></tr><tr><td>406</td><td>（not acceptable）服务端不支持所需表示</td></tr><tr><td>409</td><td>（conflict）通用冲突</td></tr><tr><td>412</td><td>（Precondition Failed）前置条件失败（如执行条件更新时的冲突）</td></tr><tr><td>415</td><td>（unsupported media type）接受到的表示不受支持</td></tr><tr><td>500</td><td>（internal server error）通用错误响应</td></tr><tr><td>503</td><td>（Service Unavailable）服务当前无法处理请求</td></tr></tbody></table><h2 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h2><p>不安全但幂等<br>用客户端管理的实例号创建一个资源<br>通过替换的方式更新资源<br>如果未被修改，则更新资源（乐观锁）</p><table><thead><tr><th>状态码</th><th>解释</th></tr></thead><tbody><tr><td>200</td><td>（OK）如果已存在资源被更改</td></tr><tr><td>201</td><td>（created）如果新资源被创建</td></tr><tr><td>301</td><td>（Moved Permanently）资源的URI已更改</td></tr><tr><td>303</td><td>（See Other）其他（如，负载均衡）</td></tr><tr><td>400</td><td>（bad request）指代坏请求</td></tr><tr><td>404</td><td>（not found）资源不存在</td></tr><tr><td>406</td><td>（not acceptable）服务端不支持所需表示</td></tr><tr><td>409</td><td>（conflict）通用冲突</td></tr><tr><td>412</td><td>（Precondition Failed）前置条件失败（如执行条件更新时的冲突）</td></tr><tr><td>415</td><td>（unsupported media type）接受到的表示不受支持</td></tr><tr><td>500</td><td>（internal server error）通用错误响应</td></tr><tr><td>503</td><td>（Service Unavailable）服务当前无法处理请求</td></tr></tbody></table><h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><p>不安全但幂等<br>删除资源</p><table><thead><tr><th>状态码</th><th>解释</th></tr></thead><tbody><tr><td>200</td><td>（OK）资源已被删除</td></tr><tr><td>301</td><td>（Moved Permanently）资源的URI已更改</td></tr><tr><td>303</td><td>（See Other）其他，如负载均衡</td></tr><tr><td>400</td><td>（bad request）指代坏请求</td></tr><tr><td>404</td><td>（not found）资源不存在</td></tr><tr><td>409</td><td>（conflict）通用冲突</td></tr><tr><td>500</td><td>（internal server error）通用错误响应</td></tr><tr><td>503</td><td>（Service Unavailable）服务端当前无法处理请求</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>CocoaTouch中的UIApplication</title>
      <link href="/2019/10/23/CocoaTouch%E4%B8%AD%E7%9A%84UIApplication/"/>
      <url>/2019/10/23/CocoaTouch%E4%B8%AD%E7%9A%84UIApplication/</url>
      
        <content type="html"><![CDATA[<h2 id="UIApplication干什么的？"><a href="#UIApplication干什么的？" class="headerlink" title="UIApplication干什么的？"></a>UIApplication干什么的？</h2><ul><li>UIApplication 的核心作用是提供了 iOS 程序运行期间的控制和协作工作。</li><li>每一个程序在运行期必须有且仅有一个 UIApplication（或则其子类）的一个实例。在程序开始运行的时候，UIApplicationMain 函数是程序进入点，这个函数做了很多工作，其中一个重要的工作就是创建一个 UIApplication 的单例实例。在你的代码中你，你可以通过调用 [UIApplication sharedApplication] 来得到这个单例实例的指针。</li><li>UIApplication 的一个主要工作是处理用户事件，它会起一个队列，把所有用户事件都放入队列，逐个处理，在处理的时候，它会发送当前事件 到一个合适的处理事件的目标控件。此外，UIApplication 实例还维护一个在本应用中打开的 window 列表（UIWindow 实例），这样它就 可以接触应用中的任何一个 UIView 对象。UIApplication 实例会被赋予一个代理对象，以处理应用程序的生命周期事件（比如程序启动和关闭）、系统事件（比如来电、记事项警告）等等。</li></ul><h2 id="UIApplication生命周期"><a href="#UIApplication生命周期" class="headerlink" title="UIApplication生命周期"></a>UIApplication生命周期</h2><ul><li><p>一个 UIApplication 可以有如下几种状态：</p><ul><li><code>Not running（未运行）</code>程序没启动</li><li><code>Inactive（未激活）</code>程序在前台运行，不过没有接收到事件。在没有事件处理情况下程序通常停留在这个状态</li><li><code>Active（激活）</code>程序在前台运行而且接收到了事件。这也是前台的一个正常的模式</li><li><code>Background（后台）</code> 程序在后台而且能执行代码，大多数程序进入这个状态后会在在这个状态上停留一会。时间到之后会进入挂起状态 (Suspended)。有的程序经过特殊的请求后可以长期处于 Background 状态</li><li><p><code>Suspended（挂起）</code>程序在后台不能执行代码。系统会自动把程序变成这个状态而且不会发出通知。当挂起时，程序还是停留在内存中的，当系统内存低时，系统就把挂起的程序清除掉，为前台程序提供更多的内存。</p></li><li><p>常见的代理方法有</p></li></ul><ol><li><p><code>(void)applicationWillResignActive:(UIApplication *)application</code></p><p>说明：当应用程序将要入非活动状态执行，在此期间，应用程序不接收消息或事件，比如来电话了</p></li><li><p><code>(void)applicationDidBecomeActive:(UIApplication *)application</code></p><p>说明：当应用程序入活动状态执行，这个刚好跟上面那个方法相反</p></li><li><p><code>(void)applicationDidEnterBackground:(UIApplication *)application</code></p><p>说明：当程序被推送到后台的时候调用。所以要设置后台继续运行，则在这个函数里面设置即可</p></li><li><p><code>(void)applicationWillEnterForeground:(UIApplication *)application</code></p><p>说明：当程序从后台将要重新回到前台时候调用，这个刚好跟上面的那个方法相反。</p></li><li><p><code>(void)applicationWillTerminate:(UIApplication *)application</code></p><p>说明：当程序将要退出是被调用，通常是用来保存数据和一些退出前的清理工作。这个需要设置 UIApplicationExitsOnSuspend 的键值。</p></li><li><p><code>(void)applicationDidReceiveMemoryWarning:(UIApplication *)application</code></p><p>说明：iPhone 设备只有有限的内存，如果为应用程序分配了太多内存操作系统会终止应用程序的运行，在终止前会执行这个方法，通常可以在这里进行内存清理工作防止程序被终止</p></li><li><p><code>(void)applicationSignificantTimeChange:(UIApplication*)application</code></p><p>说明：当系统时间发生改变时执行</p></li><li><p><code>(void)applicationDidFinishLaunching:(UIApplication*)application</code></p><p>说明：当程序载入后执行</p></li></ol></li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Objective-C中的Runtime</title>
      <link href="/2019/10/22/Objective-C%E4%B8%AD%E7%9A%84Runtime/"/>
      <url>/2019/10/22/Objective-C%E4%B8%AD%E7%9A%84Runtime/</url>
      
        <content type="html"><![CDATA[<h2 id="OC和C的区别"><a href="#OC和C的区别" class="headerlink" title="OC和C的区别"></a>OC和C的区别</h2><ul><li>OC是动态语言，C是静态语言。</li><li>OC的函数调用在编译期无法确定，C的函数调用在编译期就已经决定。</li><li>Runtime就是去解决如何在运行期间找到调用方法的问题。</li></ul><h2 id="什么是Runtime"><a href="#什么是Runtime" class="headerlink" title="什么是Runtime"></a>什么是Runtime</h2><ul><li><p>对于实例变量有如下的思路：</p><blockquote><p>instance -&gt; class -&gt; method -&gt; SEL -&gt; IMP -&gt; 实现函数</p></blockquote></li><li><p>实例对象中存放 isa 指针以及实例变量，有 isa 指针可以找到实例对象所属的类对象 (类也是对象，面向对象中一切都是对象)，类中存放着实例方法列表，在这个方法列表中 SEL 作为 key，IMP 作为 value。 在编译时期，根据方法名字会生成一个唯一的 Int 标识，这个标识就是 SEL。IMP 其实就是函数指针 指向了最终的函数实现。整个 Runtime 的核心就是 objc_msgSend 函数，通过给类发送 SEL 以传递消息，找到匹配的 IMP 再获取最终的实现。如下的这张图描述了对象的内存布局。</p></li><li><p><img src="/2019/10/22/Objective-C中的Runtime/对象的内存布局.png" srcset="/img/loading.gif" alt="对象的内存布局"></p></li><li><p>类中的 super_class 指针可以追溯整个继承链。向一个对象发送消息时，Runtime 会根据实例对象的 isa 指针找到其所属的类，并自底向上直至根类(NSObject)中 去寻找 SEL 所对应的方法，找到后就运行整个方法。</p></li><li><p>metaClass是元类，也有 isa 指针、super_class 指针。其中保存了类方法列表。</p></li></ul><h2 id="消息传递机制"><a href="#消息传递机制" class="headerlink" title="消息传递机制"></a>消息传递机制</h2><ul><li>objc_msgSend函数的消息处理过程</li><li>不涵盖消息cache机制</li><li>需要对Objective-C runtime有一定的了解</li></ul><p>如下用于描述 objc_msgSend 函数的调用流程：</p><ul><li>1.检测 SEL 是否应该被忽略</li><li>2.检测发送的 target 是否为 nil ，如果是则忽略该消息</li><li>3.<ul><li>当调用实例方法时，通过 isa 指针找到实例对应的 class 并且在其中的缓存方法列表以及方法列表中进行查询，如果找不到则根据 super_class 指针在父类中查询，直至根类(NSObject 或 NSProxy).</li><li>当调用类方法时，通过 isa 指针找到实例对应的 metaclass 并且在其中的缓存方法列表以及方法列表中进行查询，如果找不到则根据 super_class 指针在父类中查询，直至根类(NSObject 或 NSProxy). (根据此前的开篇中的图，Root Meta Class 还是有根类的。)</li></ul></li><li>如果还没找到则进入消息动态解析过程。</li></ul><h2 id="动态消息解析"><a href="#动态消息解析" class="headerlink" title="动态消息解析"></a>动态消息解析</h2><ul><li><p><img src="/2019/10/22/Objective-C中的Runtime/动态消息解析.png" srcset="/img/loading.gif" alt="动态消息解析"></p></li><li><p>如下用于描述动态消息解析的流程:</p><ul><li>1.通过 resolveInstanceMethod 得知方法是否为动态添加，YES则通过 class_addMethod 动态添加方法，处理消息，否则进入下一步。dynamic 属性就与这个过程有关，当一个属性声明为 dynamic 时 就是告诉编译器：开发者一定会添加 setter/getter 的实现，而编译时不用自动生成。</li><li>2.这步会进入 forwardingTargetForSelector 用于指定哪个对象来响应消息。如果返回nil 则进入第三步。这种方式把消息原封不动地转发给目标对象，有着比较高的效率。如果不能自己的类里面找到替代方法，可以重载这个方法，然后把消息转给其他的对象。</li><li>3.这步调用 methodSignatureForSelector 进行方法签名，这可以将函数的参数类型和返回值封装。如果返回 nil 说明消息无法处理并报错 <code>unrecognized selector sent to instance</code>，如果返回 methodSignature，则进入 forwardInvocation ，在这里可以修改实现方法，修改响应对象等，如果方法调用成功，则结束。如果依然不能正确响应消息，则报错 <code>unrecognized selector sent to instance</code>.</li></ul><p>可以利用 2、3 中的步骤实现对接受消息对象的转移，可以实现“多重继承”的效果。</p></li></ul><p>参考资料：</p><p><a href="https://hit-alibaba.github.io/interview/iOS/ObjC-Basic/Runtime.html" target="_blank" rel="noopener">https://hit-alibaba.github.io/interview/iOS/ObjC-Basic/Runtime.html</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>CocoaTouch中的事件处理</title>
      <link href="/2019/10/21/CocoaTouch%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/"/>
      <url>/2019/10/21/CocoaTouch%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="事件分类"><a href="#事件分类" class="headerlink" title="事件分类"></a>事件分类</h2><ol><li>触屏事件(Touch Event)</li><li>运动事件(Motion Event)</li><li>远端控制事件(Remote-Control Event)</li></ol><h2 id="响应者链"><a href="#响应者链" class="headerlink" title="响应者链"></a>响应者链</h2><ul><li><p>当发生事件响应时，必须知道由谁来响应事件。在 iOS 中，由响应者链来对事件进行响应。</p></li><li><p>所有事件响应的类都是 UIResponder 的子类，响应者链是一个由不同对象组成的层次结构，其中的每个对象将依次获得响应事件消息的机会。当发生事件时，事件首先被发送给第一响应者，第一响应者往往是事件发生的视图，也就是用户触摸屏幕的地方。事件将沿着响应者链一直向下传递，直到被接受并做出处理。一般来说，第一响应者是个视图对象或者其子类对象，当其被触摸后事件被交由它处理，如果它不处理，事件就会被传递给它的视图控制器对象 ViewController（如果存在），然后是它的父视图（superview）对象（如果存在），以此类推，直到顶层视图。接下来会沿着顶层视图（top view）到窗口（UIWindow 对象）再到程序（UIApplication 对象）。如果整个过程都没有响应这个事件，该事件就被丢弃。一般情况下，在响应者链中只要由对象处理事件，事件就停止传递。</p></li><li><p>一个典型的事件响应路线如下：</p><pre><code class="hljs undefined">F<span class="hljs-function"><span class="hljs-title">irst</span> Responser --&gt;</span> T<span class="hljs-function"><span class="hljs-title">he</span> Window --&gt;</span> T<span class="hljs-function"><span class="hljs-title">he</span> Application --&gt;</span> <span class="hljs-literal">nil</span>（丢弃）</code></pre></li><li><p>我们可以通过 <code>[responder nextResponder]</code> 找到当前 responder 的下一个 responder，持续这个过程到最后会找到 UIApplication 对象。</p></li><li><p>通常情况下，我们在 First Responder （一般也就是用户当前触控的 View ）这里就会响应请求，进入下面的事件分发机制。</p></li></ul><h2 id="事件分发"><a href="#事件分发" class="headerlink" title="事件分发"></a>事件分发</h2><ul><li>第一响应者（First responder）指的是当前接受触摸的响应者对象（通常是一个 UIView 对象），即表示当前该对象正在与用户交互，它是响应者链的开端。响应者链和事件分发的使命都是找出第一响应者。</li><li>iOS 系统检测到手指触摸 (Touch) 操作时会将其打包成一个 UIEvent 对象，并放入当前活动 Application 的事件队列，单例的 UIApplication 会从事件队列中取出触摸事件并传递给单例的 UIWindow 来处理，UIWindow 对象首先会使用 <code>hitTest:withEvent:</code>方法寻找此次 Touch 操作初始点所在的视图(View)，即需要将触摸事件传递给其处理的视图，这个过程称之为 hit-test view。</li><li><code>hitTest:withEvent:</code>方法的处理流程如下:<ul><li>首先调用当前视图的 <code>pointInside:withEvent:</code> 方法判断触摸点是否在当前视图内；</li><li>若返回 NO, 则 <code>hitTest:withEvent:</code> 返回 nil，若返回 YES, 则向当前视图的所有子视图 (subviews) 发送 <code>hitTest:withEvent:</code> 消息，所有子视图的遍历顺序是从最顶层视图一直到到最底层视图，即从 subviews 数组的末尾向前遍历，直到有子视图返回非空对象或者全部子视图遍历完毕；</li><li>若第一次有子视图返回非空对象，则 <code>hitTest:withEvent:</code> 方法返回此对象，处理结束；</li><li>如所有子视图都返回空，则 hitTest:withEvent: 方法返回自身 (self)。</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Objective-C中的内存管理</title>
      <link href="/2019/10/20/Objective-C%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2019/10/20/Objective-C%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="OC的内存分配机制"><a href="#OC的内存分配机制" class="headerlink" title="OC的内存分配机制"></a>OC的内存分配机制</h2><ul><li>OC中，对象通过alloc在堆上创建，一旦对象创建完成，就不能在再移动。</li></ul><h2 id="MRC和ARC"><a href="#MRC和ARC" class="headerlink" title="MRC和ARC"></a>MRC和ARC</h2><ul><li>OC中提供两种内存管理机制：MRC(Mannual Reference Counting)和ARC(Automatic Reference Counting)，指手动和自动管理，现在推荐使用ARC来管理内存。</li></ul><h2 id="MRC"><a href="#MRC" class="headerlink" title="MRC"></a>MRC</h2><table><thead><tr><th>对象操作</th><th style="text-align:center">OC中对应的方法</th><th style="text-align:center">对应的 retainCount 变化</th></tr></thead><tbody><tr><td>生成并持有对象</td><td style="text-align:center">alloc/new/copy/mutableCopy等</td><td style="text-align:center">+1</td></tr><tr><td>持有对象</td><td style="text-align:center">retain</td><td style="text-align:center">+1</td></tr><tr><td>释放对象</td><td style="text-align:center">release</td><td style="text-align:center">-1</td></tr><tr><td>废弃对象</td><td style="text-align:center">dealloc</td><td style="text-align:center">-</td></tr></tbody></table><h2 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h2><ul><li>ARC 是苹果引入的一种自动内存管理机制，会根据引用计数自动监视对象的生存周期，实现方式是在编译时期自动在已有代码中插入合适的内存管理代码以及在 Runtime 做一些优化。</li><li>在ARC中与内存管理有关的变量标识符，有下面几种：<ul><li><code>__strong</code></li><li><code>__weak</code></li><li><code>__unsafe_unretained</code></li><li><code>__autoreleasing</code></li></ul></li><li><code>__strong</code> 是默认使用的标识符。只有还有一个强指针指向某个对象，这个对象就会一直存活。</li><li><code>__weak</code> 声明这个引用不会保持被引用对象的存活，如果对象没有强引用了，弱引用会被置为 nil。</li><li><code>__unsafe_unretained</code> 声明这个引用不会保持被引用对象的存活，如果对象没有强引用了，它不会被置为 nil。如果它引用的对象被回收掉了，该指针就变成了野指针。</li><li><code>__autoreleasing</code> 用于标示使用引用传值的参数（id *），在函数返回时会被自动释放掉。</li><li>或者可以用属性标识符，前面的博客有提到</li></ul><h2 id="Autorelease-Pool"><a href="#Autorelease-Pool" class="headerlink" title="Autorelease Pool"></a>Autorelease Pool</h2><ul><li><p>在 ARC 下，我们并不需要手动调用 autorelease 有关的方法，甚至可以完全不知道 autorelease 的存在，就可以正确管理好内存。因为 Cocoa Touch 的 Runloop 中，每个 runloop circle 中系统都自动加入了 Autorelease Pool 的创建和释放。</p></li><li><p>当我们需要创建和销毁大量的对象时，使用手动创建的 autoreleasepool 可以有效的避免内存峰值的出现。因为如果不手动创建的话，外层系统创建的 pool 会在整个 runloop circle 结束之后才进行 drain，手动创建的话，会在 block 结束之后就进行 drain 操作。一个普遍被使用的例子如下：</p><pre><code class="hljs objectivec"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000000</span>; i++)&#123;    <span class="hljs-keyword">@autoreleasepool</span>    &#123;        <span class="hljs-built_in">NSString</span>* string = <span class="hljs-string">@"ab c"</span>;        <span class="hljs-built_in">NSArray</span>* array = [string componentsSeparatedByString:string];    &#125;&#125;</code></pre><p>如果不使用 autoreleasepool ，需要在循环结束之后释放 100000000 个字符串，如果 使用的话，则会在每次循环结束的时候都进行 release 操作。</p></li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Objective-C中的Block</title>
      <link href="/2019/10/19/Objective-C%E4%B8%AD%E7%9A%84Block/"/>
      <url>/2019/10/19/Objective-C%E4%B8%AD%E7%9A%84Block/</url>
      
        <content type="html"><![CDATA[<h2 id="Block的定义"><a href="#Block的定义" class="headerlink" title="Block的定义"></a>Block的定义</h2><ul><li>一种匿名函数，语法如下：</li><li><code>return_type (^block_name)(parameters)</code></li><li><strong>注意</strong>：Block是一种OC对象；当Block作为函数参数时应该放在参数列表的最后一个</li></ul><h2 id="多种场景下的Block语法"><a href="#多种场景下的Block语法" class="headerlink" title="多种场景下的Block语法"></a>多种场景下的Block语法</h2><ol><li><p>作为变量</p><p><code>returnType (^blockName)(parameterTypes) = ^returnType(parameters) {...};</code></p></li><li><p>作为属性</p><p><code>@property (nonatomic, copy) returnType (^blockName)(parameterTypes);</code></p></li><li><p>函数中的参数</p><p><code>- (void)someMethodThatTakesABlock:(returnType (^)(parameterTypes))blockName;</code></p></li><li><p>调用函数时的参数</p><p><code>[someObject someMethodThatTakesABlock:^returnType (parameters) {...}];</code></p></li><li><p>作为typedef</p><pre><code class="hljs objectivec"><span class="hljs-keyword">typedef</span> returnType (^TypeName)(parameterTypes);TypeName blockName = ^returnType(parameters) &#123;...&#125;;</code></pre></li></ol><h2 id="为何Block内的self要弱引用？"><a href="#为何Block内的self要弱引用？" class="headerlink" title="为何Block内的self要弱引用？"></a>为何Block内的self要弱引用？</h2><ul><li><p>在非 ARC 的情况下，对于 block 类型的属性应该使用 <code>copy</code> ，因为 block 需要维持其作用域中捕获的变量。在 ARC 中编译器会自动对 block 进行 copy 操作，因此使用 <code>strong</code> 或者 <code>copy</code> 都可以，没有什么区别，但是苹果仍然建议使用 <code>copy</code> 来指明编译器的行为。</p></li><li><p>lock 在捕获外部变量的时候，会保持一个强引用，当在 block 中捕获 <code>self</code> 时，由于对象会对 block 进行 <code>copy</code>，于是便形成了强引用循环：</p></li><li><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">BlockKeeper</span> : <span class="hljs-title">NSObject</span></span><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">copy</span>) <span class="hljs-keyword">void</span> (^block)(<span class="hljs-keyword">void</span>);<span class="hljs-keyword">@end</span></code></pre><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">BlockKeeper</span></span>- (<span class="hljs-keyword">void</span>)configureBlock &#123;    <span class="hljs-keyword">self</span>.block = ^&#123;        [<span class="hljs-keyword">self</span> doSomething];    <span class="hljs-comment">// capturing a strong reference to self</span>                               <span class="hljs-comment">// creates a strong reference cycle</span>    &#125;;&#125;...<span class="hljs-keyword">@end</span></code></pre></li><li><p>为了避免强引用循环，最好对self弱引用：</p><pre><code class="hljs objectivec">- (<span class="hljs-keyword">void</span>)configureBlock &#123;    BlockKeeper * __<span class="hljs-keyword">weak</span> weakSelf = <span class="hljs-keyword">self</span>;    <span class="hljs-keyword">self</span>.block = ^&#123;        [weakSelf doSomething];   <span class="hljs-comment">// capture the weak reference</span>                                  <span class="hljs-comment">// to avoid the reference cycle</span>    &#125;&#125;</code></pre></li><li><p>使用弱引用会带来另一个问题，<code>weakSelf</code> 有可能会为 nil，如果多次调用 <code>weakSelf</code> 的方法，有可能在 block 执行过程中 <code>weakSelf</code> 变为 nil。因此需要在 block 中将 <code>weakSelf</code> “强化“</p></li><li><pre><code class="hljs objectivec">__<span class="hljs-keyword">weak</span> __typeof__(<span class="hljs-keyword">self</span>) weakSelf = <span class="hljs-keyword">self</span>;<span class="hljs-built_in">NSBlockOperation</span> *op = [[[<span class="hljs-built_in">NSBlockOperation</span> alloc] init] autorelease];[ op addExecutionBlock:^ &#123;    __<span class="hljs-keyword">strong</span> __typeof__(<span class="hljs-keyword">self</span>) strongSelf = weakSelf;    [strongSelf doSomething];    [strongSelf doMoreThing];&#125; ];[someOperationQueue addOperation:op];__<span class="hljs-keyword">strong</span>` 这一句在执行的时候，如果 WeakSelf 还没有变成 <span class="hljs-literal">nil</span>，那么就会 <span class="hljs-keyword">retain</span> <span class="hljs-keyword">self</span>，让 <span class="hljs-keyword">self</span> 在 block 执行期间不会变为 <span class="hljs-literal">nil</span>。这样上面的 `doSomething` 和 `doMoreThing` 要么全执行成功，要么全失败，不会出现一个成功一个失败，即执行到中间 `<span class="hljs-keyword">self</span>` 变成 <span class="hljs-literal">nil</span> 的情况。</code></pre></li><li><p><code>__strong</code> 这一句在执行的时候，如果 WeakSelf 还没有变成 nil，那么就会 retain self，让 self 在 block 执行期间不会变为 nil。这样上面的 <code>doSomething</code> 和 <code>doMoreThing</code> 要么全执行成功，要么全失败，不会出现一个成功一个失败，即执行到中间 <code>self</code> 变成 nil 的情况。</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://hit-alibaba.github.io/interview/iOS/ObjC-Basic/Block.html" target="_blank" rel="noopener">https://hit-alibaba.github.io/interview/iOS/ObjC-Basic/Block.html</a></li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Objective-C中的Runloop</title>
      <link href="/2019/10/19/Objective-C%E4%B8%AD%E7%9A%84Runloop/"/>
      <url>/2019/10/19/Objective-C%E4%B8%AD%E7%9A%84Runloop/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Runloop"><a href="#什么是Runloop" class="headerlink" title="什么是Runloop"></a>什么是Runloop</h2><ul><li><p>高级一点的循环</p></li><li><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CFRunLoopRun</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<span class="hljs-comment">/* DOES CALLOUT */</span>    <span class="hljs-keyword">int32_t</span> result;    <span class="hljs-keyword">do</span> &#123;        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, <span class="hljs-number">1.0e10</span>, <span class="hljs-literal">false</span>);        CHECK_FOR_FORK();    &#125; <span class="hljs-keyword">while</span> (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);&#125;</code></pre></li><li><p>让线程在需要做事的时候忙起来，不需要的时候就休眠</p></li></ul><h2 id="Runloop的作用"><a href="#Runloop的作用" class="headerlink" title="Runloop的作用"></a>Runloop的作用</h2><ol><li>保持程序运行，循环避免线程被销毁</li><li>处理App的各种事件(触摸、定时器)</li><li>节省cpu资源，提高程序性能</li></ol><h2 id="Runloop和线程的关系"><a href="#Runloop和线程的关系" class="headerlink" title="Runloop和线程的关系"></a>Runloop和线程的关系</h2><p><img src="/2019/10/19/Objective-C中的Runloop/Runloop.png" srcset="/img/loading.gif" alt="Runloop"></p><ul><li>很明显的可以看出Runloop从 input source 和 timer source 接受事件，然后在线程中处理事件。</li><li>Runloop和线程是绑定的。每个线程都有一个对应的Runloop对象，我们无法自己创建，但可以获取系统提供的Runloop对象。</li><li>主线程的 Runloop 会在应用启动的时候完成启动，其他线程的 Runloop 默认并不会启动，需要我们手动启动。</li></ul><h2 id="Input-Source和Timer-Source"><a href="#Input-Source和Timer-Source" class="headerlink" title="Input Source和Timer Source"></a>Input Source和Timer Source</h2><ul><li>Runloop事件的来源，其中Input Source又分为三类：<ol><li>Port-Based Sources，系统底层的Port事件，例如CFSocketRef，在应用层基本用不到</li><li>Custom Input Sources，用户手动创建的Source</li><li>Cocoa Perform Selector Sources，Cocoa提供的performSelector系列方法，也是一种事件源</li></ol></li><li>Timer Source是定时器事件</li></ul><h2 id="Runloop-Observer"><a href="#Runloop-Observer" class="headerlink" title="Runloop Observer"></a>Runloop Observer</h2><ul><li>用于监控一下runloop事件：进入、定时器阶段、输入源阶段、休眠、唤醒前、退出</li></ul><h2 id="Runloop-Mode"><a href="#Runloop-Mode" class="headerlink" title="Runloop Mode"></a>Runloop Mode</h2><ul><li>不同的Mode其实是对Source、Timer和Observe的不同组合方式</li><li>共有五种Mode：NSDefaultRunLoopMode、NSConnectionReplyMode、NSModalPanelRunLoopMode、NSEventTrackingRunLoopMode、NSRunLoopCommonModes</li><li>NSRunLoopCommonModes 实际上是一个 Mode 的集合，默认包括 NSDefaultRunLoopMode 和 NSEventTrackingRunLoopMode。</li></ul><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ul><li>开发中，常遇到滚动scrollview或tableview时，自定义的轮播图停止计时，无法正常轮播的情况，本质上是NSTimer的问题。</li><li>由于一个timer一次只能加入到一个Runloop中，而且在runloop的NSDefaultRunLoopMode下，主线程Runloop会转到UITrackingRunLoopMode下，此时timer停止计时。</li><li>解决方法有两种：<ol><li>将NSTimer指定运行于NSRunLoopCommonModes，这样无论当前runloop运行哪个mode，事件都能得到执行。</li><li>将计时器放到另一个线程上，主线程更新UI，这样runloop不会冲突。</li></ol></li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Objective-C中的关键字分析</title>
      <link href="/2019/10/18/Objective-C%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E5%88%86%E6%9E%90/"/>
      <url>/2019/10/18/Objective-C%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="OC中有哪些关键字？"><a href="#OC中有哪些关键字？" class="headerlink" title="OC中有哪些关键字？"></a>OC中有哪些关键字？</h2><ul><li>copy、assign、strong、retain、weak、readonly、readwrite、nonatomic、atomic……</li></ul><h2 id="深入理解他们前需要了解的基本概念"><a href="#深入理解他们前需要了解的基本概念" class="headerlink" title="深入理解他们前需要了解的基本概念"></a>深入理解他们前需要了解的基本概念</h2><ul><li><strong>野指针</strong>：野指针就是指向垃圾内存的指针，这个指针地址不是NULL。指向的对象被释放了，但是这个指针还没有置为nil，再次访问指向的值的时候就会出现不可预期的错误。</li><li><strong>僵尸指针</strong>：是野指针的一种情况，指向的对象被释放，但指针没有被赋成nil。</li><li><strong>僵尸对象</strong>：被释放的对象，在程序中被再度使用。</li><li><strong>内存泄漏</strong>：如果程序运行时一直分配内存而不及时释放无用的内存，程序占用的内存越来越大，直到把系统分配给该APP的内存消耗殚尽，程序因无内存可用导致崩溃，这样的情况我们称之为内存泄漏。</li></ul><h2 id="关键属性介绍"><a href="#关键属性介绍" class="headerlink" title="关键属性介绍"></a>关键属性介绍</h2><ul><li><p>property的默认属性是：readwrite、assign、atomic</p></li><li><p><strong>assign</strong>：用于修饰基本数据类型(NSInteger、CGFloat)和C数据类型(int、float、double、char等)，简单赋值，不更改引用计数。<em>id必须用assign</em></p></li><li><p><strong>weak</strong>：不增加引用计数。指向的地址一旦被释放，这些指针都将被赋值为nil。能攻有效防止野指针。</p></li><li><p><strong>retain</strong>：在非ARC时代，你需要自己retain一个想要保持的对象（保其命），ARC环境下就不需要了。现在唯一要做的就是用一个指针指向这个对象，只要指针没有被重置为空，对象就会一直在堆上。当指针指向新值的时候，原来的对象就会被release一次。</p></li><li><p><strong>strong</strong>：在ARC环境下，只要某一对象被一个strong指针指向，该对象就不会被销毁。如果对象没有被任何strong指针指向，那么就会被销毁。在默认情况下，所有的实例变量和局部变量都是strong类型的。可以说strong类型的指针在行为上跟非ARC下得retain是比较相似的。在ARC环境下，strong代替了retain，所以现在一般都是些strong。(浅复制)</p></li><li><p><strong>copy</strong>：新建一个对象并指向他。(深复制)</p></li><li><p><strong>readonly</strong>：只读，只生成getter方法，不生成setter方法。</p></li><li><p><strong>readwrite</strong>：读写，默认属性。存取器方法都需要在@implementation中实现（已经声明了）。如果使用@synthesize关键字，存取器方法都会被自动创建</p></li><li><p><strong>nonatomic</strong>：非原子性操作。非线程安全。</p></li><li><p><strong>atomic</strong>：原子性操作，默认属性。线程安全。</p></li><li><p><strong>synthesize</strong>和<strong>dynamic</strong>：</p><ol><li><p>@property有两个对应的词，一个是@synthesize，一个是@dynamic。如果@synthesize和@dynamic都没写，那么默认的就是@syntheszie var = _var;</p></li><li><p>@synthesize的语义是如果你没有手动实现setter方法和getter方法，那么编译器会自动为你加上这两个方法</p></li><li><p>@dynamic告诉编译器,属性的setter与getter方法由用户自己实现，不自动生成。</p></li></ol></li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Objective-C中的Category和Extension</title>
      <link href="/2019/10/17/Objective-C%E4%B8%AD%E7%9A%84Category%E5%92%8CExtension/"/>
      <url>/2019/10/17/Objective-C%E4%B8%AD%E7%9A%84Category%E5%92%8CExtension/</url>
      
        <content type="html"><![CDATA[<h1 id="Objective-C中的Category-分类-和Extension-类扩展"><a href="#Objective-C中的Category-分类-和Extension-类扩展" class="headerlink" title="Objective-C中的Category(分类)和Extension(类扩展)"></a>Objective-C中的Category(分类)和Extension(类扩展)</h1><h2 id="Category-分类"><a href="#Category-分类" class="headerlink" title="Category(分类)"></a>Category(分类)</h2><ul><li><p>Category可以动态地为已有类添加新行为</p></li><li><p>代码越写越多，维护性就越来越差，而分类的特性可以将类的实现分开在几个不同的文件中，Category的优势可以简单描述为：</p><ol><li>减小单个文件体积</li><li>功能分散开，便于维护管理</li></ol></li><li><p>Category能购添加<strong>实例方法，类方法，协议，属性</strong>，不能添加<strong>实例变量</strong></p></li><li><p>Category的重名方法会”覆盖”原有类的方法？</p><p>​    此处的覆盖并非真正的覆盖，而是Category中的同名方法被排到了方法列表的前面，当编译器在<em>运行时</em>查找方法时找到列表中的第一个对应的方法时，就返回了。</p></li></ul><h2 id="Extension-类扩展"><a href="#Extension-类扩展" class="headerlink" title="Extension(类扩展)"></a>Extension(类扩展)</h2><ul><li><p>在.m文件中</p><pre><code class="hljs objective-c">@interface@end</code></pre></li><li><p>一般用来申明私有方法、私有属性和私有成员变量。</p></li><li><p>Extension在<em>编译期</em>决议</p></li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>三次握手和四次挥手</title>
      <link href="/2019/10/16/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
      <url>/2019/10/16/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="关于三次握手和四次挥手的一些整理"><a href="#关于三次握手和四次挥手的一些整理" class="headerlink" title="关于三次握手和四次挥手的一些整理"></a>关于三次握手和四次挥手的一些整理</h1><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><ul><li><p>指在建立TCP连接时，需要客户端和服务器总共发送3个包，简称三次握手(Three-way Handshake)。它的主要作用是为了确认双方的接受能力和发送能力是否正常，实质上是连接服务器指定端口，建立TCP连接，同步连接双方的确认号，交换TCP窗口大小信息。</p></li><li><p>当客户端处于Closed状态，服务端处于Listen状态，进行三次握手：</p><ol><li><p>第一次握手：客户端给服务端发送SYN报文，并指明客户端的初始化序列号ISN(c)。此时客户端处于SYN_SEND状态。</p><p>首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。</p></li><li><p>第二次握手：服务端收到客户端的SYN报文之后，会以自己的SYN报文作为应答，并且也是指定了自己的初始化序列号ISN(s)。同时会把客户端的ISN+1作为ACK的值，表示自己已经收到了客户端的SYN，此时服务器处于SYN_REVD的状态。</p><p>在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。</p></li><li><p>第三次握手：客户端收到SYN报文之后，会发送一个ACK报文，把ISN+1作为ACK的值，表示已经收到了服务端的SYN报文，此时客户端处于ESTABLISHED状态。服务端收到ACK报文之后，也处于ESTABLISHED状态，此时双方建立连接。</p><p>在确认报文段ACK=1，确认号ack=y+1，序号seq=x+1(初始为seq=x，第二个报文段+1)，ACK报文段可以携带数据，不携带数据则不消耗序号。</p></li></ol><p>在Socket编程中，客户端执行connect()时，将触发三次握手。</p><p><img src="/2019/10/16/三次握手和四次挥手/三次握手.jpg" srcset="/img/loading.gif" alt="三次握手四次挥手"></p></li></ul><h2 id="为什么一定要三次握手呢？"><a href="#为什么一定要三次握手呢？" class="headerlink" title="为什么一定要三次握手呢？"></a>为什么一定要三次握手呢？</h2><ul><li><p>三次握手的目的：</p><ol><li>第一次握手：客户端发送网络包，服务端收到了。 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</li><li>第二次握手：服务端发包，客户端收到了。 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</li><li>第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</li></ol><p>所以我们需要三次握手来达成校验的目的。</p></li></ul><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><ul><li><p>建立一个连接需要三次握手，终止一个连接需要四次挥手。</p></li><li><p>四次挥手过程如下：</p><ol><li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 <code>FIN_WAIT1</code> 状态。 即发出<strong>连接释放报文段</strong>（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。</li><li>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 <code>CLOSE_WAIT</code> 状态。 即服务端收到连接释放报文段后即发出<strong>确认报文段</strong>（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。</li><li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 <code>LAST_ACK</code> 的状态。 即服务端没有要向客户端发出的数据，服务端发出<strong>连接释放报文段</strong>（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。</li><li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 <code>TIME_WAIT</code> 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 <code>CLOSED</code> 状态。 即客户端收到服务端的连接释放报文段后，对此发出<strong>确认报文段</strong>（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。</li></ol><p>在Socket编程中，任何一端close()操作即可产生挥手操作。</p><p><img src="/2019/10/16/三次握手和四次挥手/四次挥手.jpeg" srcset="/img/loading.gif" alt="三次握手四次挥手"></p><h2 id="为什么挥手四次？"><a href="#为什么挥手四次？" class="headerlink" title="为什么挥手四次？"></a>为什么挥手四次？</h2><ul><li>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中<strong>ACK报文是用来应答的，SYN报文是用来同步的</strong>。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，”你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。</li></ul><h2 id="等待2MSL的意义？"><a href="#等待2MSL的意义？" class="headerlink" title="等待2MSL的意义？"></a>等待2MSL的意义？</h2><ul><li><strong>MSL是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</strong></li><li>为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。</li></ul></li></ul><p>参考链接：<a href="https://juejin.im/post/5d9c284b518825095879e7a5" target="_blank" rel="noopener">https://juejin.im/post/5d9c284b518825095879e7a5</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>伪随机数机制</title>
      <link href="/2019/10/15/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/10/15/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="伪随机数机制"><a href="#伪随机数机制" class="headerlink" title="伪随机数机制"></a>伪随机数机制</h2><ul><li><p>伪随机数是什么</p><ol><li>看似随机生成实则有周期性序列</li><li>由算法生成的必然是伪随机数，只能通过优化算法不断接近随机</li></ol></li><li><p>真随机数呢？</p><p>通过真实随机事件取得的随机数</p></li><li><p>Java中产生随机数的两种方法</p><pre><code class="hljs java">Math.random()<span class="hljs-keyword">new</span> Random()</code></pre></li></ul><ol><li><p>Math.random</p><p>返回取值范围[0.0, 1.0)的double值，由于小数点后可以保留到15位，产生相同的数的可能性较小，在一定程度上随机</p></li><li><p>java.util.Random</p><p>有两种构造方法</p><pre><code class="hljs java">Random() <span class="hljs-comment">//使用一个和当前系统时间对应的相对时间有关的数字作为种子数</span>Random(<span class="hljs-keyword">long</span> seed) <span class="hljs-comment">//直接传入一个种子数</span></code></pre><p><strong>什么是种子数？</strong></p><p>种子就是产生随机数的第一次使用值,机制是通过一个函数,将这个种子的值转化为随机数空间中的某一个点上,并且产生的随机数均匀的散布在空间中。以后产生的随机数都与前一个随机数有关。</p></li></ol><ul><li><p>小结</p><ol><li>设定好种子后，N个随机数已经确定</li><li>Java随机数是通过算法实现的，是伪随机数</li><li>java.util.Random()相对灵活</li></ol></li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>初探线程池模式</title>
      <link href="/2019/10/14/%E5%88%9D%E6%8E%A2%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/10/14/%E5%88%9D%E6%8E%A2%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="设计模式之线程池模式-Thread-Pool"><a href="#设计模式之线程池模式-Thread-Pool" class="headerlink" title="设计模式之线程池模式 Thread Pool"></a>设计模式之线程池模式 Thread Pool</h2><ul><li><p>背景</p><p>线程对于要处理的任务来说是一种非常有限的资源，除了要消耗CPU和内存，线程调用的栈也占内存，所以为每一个或每一组任务创建一个线程是一件很奢侈的事。</p></li><li><p>核心思想</p><p><strong>常用的做法是使用一定数量的线程，让这些线程去执行不断产生的任务</strong></p><p>以下这段摘自网络，原文链接：<a href="https://blog.csdn.net/buyoufa/article/details/51869942" target="_blank" rel="noopener">https://blog.csdn.net/buyoufa/article/details/51869942</a></p><pre><code class="hljs undefined">ThreadPool类负责接收和存储任务以及工作者线程的生命管理。submit用于接收一个任务，客户端代码调用该方法想线程池提交一个任务；<span class="hljs-built_in">shutdown</span>关闭线程池对外提供的服务Promise可借以获取相应任务执行结果的凭据对象。setResule获取相应任务执行结果的执行结果，getResule设置相应任务执行结果的执行结果。WorkQueue工作队列，实现任务的缓存。enqueue将任务存入队列，dequeue从队列中取出一个任务。WorkerThread负责任务执行的工作这线程。<span class="hljs-built_in">run</span>逐一从工作队列中取出任务执行，runTask执行制定的任务。</code></pre><p><img src="/2019/10/14/初探线程池模式/线程池模式.png" srcset="/img/loading.gif" alt="线程池模式"></p></li><li><p>线程池模式的优势</p><ol><li>抵消线程创建的开销，提高响应性</li><li>封装了工作者线程生命周期管理</li><li>减少销毁线程的开销</li></ol></li><li><p>线程池模式的劣势</p><ol><li><p>工作队列的选择：通常有三种队列方式，有界队列（BoundedQueue）工作队列本身并不限制线程池中等待运行的任务的数量，但工作队列中实际可容纳的任务取决于任务本身对资源的使用情况；无界队列(UnboundQueue)工作队列限定线程池中等待大人物的数量，在一定成都上可以限制资源的消耗；直接交接队列(SymchrinousQueue)不适用缓冲空间内部提交任务的时候调用的是工作队列的非阻塞式入队列方法，所以没有等待队列，会有新的线程对入队列失败的任务进行处理。</p></li><li><p>线程池大小调校：太大了浪费资源，太大无法充分利用资源，所以线程池大小取决于该线程池所要处理任务的特性，系统资源以及任务锁使用的稀缺资源状况。</p></li><li>线程池监控：线程池的大小，工作队列的容量，线程空闲时间限制这些熟悉的调试过程需要有程序去监控来方便调试ThreadPoolExecutor类提供了监控的方法。</li><li>线程泄露：线程池中的工作者线程会意外终止，使得线程池中实际可用的工作者线程减少。出现的原因是线程对象的run方法的异常处理没有捕获RuntimeException和Error导致run方法意外返回，使得相应线程意外终止。所以要注入捕获相应异常。但是还有一种可能情况需要注意，如果线程需要请求外部资源而且对外部资源的请求没有时间限制的话，线程实际上可能已经泄露了。</li><li>可靠性和线程池饱和处理策略：工作队列的选择对于线程大小需求变化没有处理方式，所以需要线程饱和处理策略。</li><li>死锁：线程请求类似的资源可能形成死锁。</li><li>线程池空闲线程清理：过长时间没有进行任务处理的线程是对系统资源的浪费，所以需要相应的处理代码。</li></ol></li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>GCD多线程整理</title>
      <link href="/2019/10/14/GCD%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%95%B4%E7%90%86/"/>
      <url>/2019/10/14/GCD%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="OC多线程：对于GCD的一些整理"><a href="#OC多线程：对于GCD的一些整理" class="headerlink" title="OC多线程：对于GCD的一些整理"></a>OC多线程：对于GCD的一些整理</h2><ul><li><p>一、介绍</p><p><code>Grand Central Dispatch(GCD) 是 Apple 开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。是一个在线程池模式的基础上执行的并发任务</code></p><p><strong>优势</strong></p><ol><li>GCD 可用于多核的并行运算</li><li>GCD 会自动利用更多的 CPU 内核（比如双核、四核）</li><li>GCD 会自动管理线程的生命周期（创建线程、调度任务、销毁线程）</li><li>程序员只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码 </li></ol></li><li><p>二、任务</p><p><code>GCD的block执行的代码块，分为同步执行（sync）和异步执行（async）</code></p><p><strong>区别在于</strong>是否等待队列的任务执行结束，以及是否具备开启新线程的能力</p></li><li><p>三、队列(Dispatch Queue)</p><p><code>采用FIFO先进先出原则</code></p><p>包含<strong>串行队列</strong>和<strong>并发队列</strong></p><p><strong>串行队列</strong>：只开启一个线程，执行完一个在进行下一个</p><p><strong>并发队列</strong>：可开启多个线程，并且同时执行任务，只有在异步函数(dispach_async)下才有效</p></li><li><p>四、使用步骤</p><ol><li>创建一个队列（串行队列或并发队列）</li><li>将任务追加到任务的等待队列中，然后系统就会根据任务类型执行任务（同步执行或异步执行）</li></ol><p>任务和队列的几种组合：</p><p>|      | 串行队列                    | 并发队列                 | 主队列                   |<br>| —- | ————————— | ———————— | ———————— |<br>| 同步 | 不开新线程，串行执行任务    | 不开新线程，串行执行任务 | 不开新线程，串行执行任务 |<br>| 异步 | 开新线程(1条)，串行执行任务 | 开新线程，并发执行任务   | 不开新线程，串行执行任务 |</p></li><li><p>五、几种组合的使用</p><ol><li><p>同步+串行</p><pre><code class="hljs objective-c">+ (void) syncSerial&#123;    NSLog(@&quot;当前线程：%@&quot;,[NSThread currentThread]);    NSLog(@&quot;同步串行任务开始&quot;);    dispatch_queue_t queue = dispatch_queue_create(&quot;net.gcd.syncSerialQueue&quot;, DISPATCH_QUEUE_SERIAL);    dispatch_async(queue, ^&#123;        for (NSInteger index = 0; index &lt; 2; index ++ ) &#123;            [NSThread sleepForTimeInterval:2];                         NSLog(@&quot;任务1线程: %@&quot;,[NSThread currentThread]);        &#125;    &#125;);    dispatch_async(queue, ^&#123;        for (NSInteger index = 0; index &lt; 2; index ++ ) &#123;            [NSThread sleepForTimeInterval:2];                                NSLog(@&quot;任务2线程: %@&quot;,[NSThread currentThread]);             &#125;    &#125;);    dispatch_async(queue, ^&#123;        for (NSInteger index = 0; index &lt; 2; index ++ ) &#123;            [NSThread sleepForTimeInterval:2];                                NSLog(@&quot;任务3线程: %@&quot;,[NSThread currentThread]);              &#125;    &#125;);    NSLog(@&quot;同步串行任务结束&quot;);&#125;</code></pre></li><li><p>异步+串行</p><pre><code class="hljs objective-c">+ (void) asyncSerial&#123;    NSLog(@&quot;当前线程：%@&quot;,[NSThread currentThread]);    NSLog(@&quot;异步串行任务开始&quot;);    dispatch_queue_t queue = dispatch_queue_create(&quot;net.gcd.asyncSerialQueue&quot;, DISPATCH_QUEUE_SERIAL);    dispatch_async(queue, ^&#123;        for (NSInteger index = 0; index &lt; 2; index ++ ) &#123;            [NSThread sleepForTimeInterval:2];            NSLog(@&quot;任务1线程: %@&quot;,[NSThread currentThread]);        &#125;    &#125;);    dispatch_async(queue, ^&#123;        for (NSInteger index = 0; index &lt; 2; index ++ ) &#123;            [NSThread sleepForTimeInterval:2];            NSLog(@&quot;任务2线程: %@&quot;,[NSThread currentThread]);        &#125;    &#125;);    dispatch_async(queue, ^&#123;        for (NSInteger index = 0; index &lt; 2; index ++ ) &#123;            [NSThread sleepForTimeInterval:2];            NSLog(@&quot;任务3线程: %@&quot;,[NSThread currentThread]);        &#125;    &#125;);    NSLog(@&quot;异步串行任务结束&quot;);&#125;</code></pre></li><li><p>同步+并发</p><pre><code class="hljs objective-c">+ (void)syncConcurrent&#123;    NSLog(@&quot;当前线程 : %@&quot;,[NSThread currentThread]);    NSLog(@&quot;同步并发任务开始&quot;);    dispatch_queue_t queue = dispatch_queue_create(&quot;net.gcd.syncConQueue&quot;, DISPATCH_QUEUE_CONCURRENT);        dispatch_sync(queue, ^&#123;        for (NSInteger index = 0; index &lt; 2; index ++ ) &#123;            [NSThread sleepForTimeInterval:2];            NSLog(@&quot;任务1线程: %@&quot;,[NSThread currentThread]);        &#125;            &#125;);        dispatch_sync(queue, ^&#123;        for (NSInteger index = 0; index &lt; 2; index ++ ) &#123;            [NSThread sleepForTimeInterval:2];            NSLog(@&quot;任务2线程: %@&quot;,[NSThread currentThread]);        &#125;            &#125;);        dispatch_sync(queue, ^&#123;        for (NSInteger index = 0; index &lt; 2; index ++ ) &#123;            [NSThread sleepForTimeInterval:2];            NSLog(@&quot;任务3线程: %@&quot;,[NSThread currentThread]);        &#125;            &#125;);    NSLog(@&quot;同步并发任务结束&quot;);&#125;</code></pre></li><li><p>异步+并发</p><pre><code class="hljs objective-c">+ (void) asyncConcurrent&#123;    NSLog(@&quot;当前线程：%@&quot;,[NSThread currentThread]);    NSLog(@&quot;异步并发任务开始&quot;);    dispatch_queue_t queue = dispatch_queue_create(&quot;net.gcd.asyncConQueue&quot;, DISPATCH_QUEUE_CONCURRENT);    dispatch_async(queue, ^&#123;        for (NSInteger index = 0; index &lt; 2; index ++ ) &#123;            [NSThread sleepForTimeInterval:2];            NSLog(@&quot;任务1线程: %@&quot;,[NSThread currentThread]);        &#125;    &#125;);    dispatch_async(queue, ^&#123;        for (NSInteger index = 0; index &lt; 2; index ++ ) &#123;            [NSThread sleepForTimeInterval:2];            NSLog(@&quot;任务2线程: %@&quot;,[NSThread currentThread]);        &#125;    &#125;);    dispatch_async(queue, ^&#123;        for (NSInteger index = 0; index &lt; 2; index ++ ) &#123;            [NSThread sleepForTimeInterval:2];            NSLog(@&quot;任务3线程: %@&quot;,[NSThread currentThread]);        &#125;    &#125;);    NSLog(@&quot;异步并发任务结束&quot;);&#125;</code></pre></li><li><p>同步+主队列</p><p>不可用，会造成死锁。</p><p><strong>原因</strong>：当在主线程中执行syncMainTask方法，相当于把syncMainTask 任务放到了主线程的队列中。 而同步执行会等待当前队列中的任务执行完毕，才会接着执行下一个任务。那么当把任务1追加到主队列中，任务1就在等待主线程处理syncMainTask任务，而syncMainTask任务需要等待任务1执行完毕，才会接着执行。那么，当syncMainTask任务和任务1都在等待对方执行完毕，这就导致了线程卡住了，队列中的任务也执行不了。</p></li><li><p>异步+主队列</p><p>通异步+串行</p></li></ol></li><li><p>六、线程间的通讯</p><p>将耗时的任务放到其他线程上，如图片下载、文件上传等耗时的网络请求操作，将UI刷新放到主线程。完成耗时操作之后回到主线程就实现了线程间的通讯。</p><pre><code class="hljs objective-c">+ (void) threadConnection &#123;    // 获取全局并发队列    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);        // 获取主队列    dispatch_queue_t mainQueue = dispatch_get_main_queue();        dispatch_async(queue, ^&#123;        //异步处理一些耗时操作的数据                for (NSInteger index = 0; index &lt; 2; index ++ ) &#123;            [NSThread sleepForTimeInterval:2];                    // 休眠2s，模拟耗时操作            NSLog(@&quot;异步线程: %@&quot;,[NSThread currentThread]);       // 打印当前线程        &#125;                dispatch_async(mainQueue, ^&#123;            //主线程，更新UI等等                        [NSThread sleepForTimeInterval:2];                    // 休眠2s，模拟耗时操作            NSLog(@&quot;主线程: %@&quot;,[NSThread currentThread]);       // 打印当前线程        &#125;);    &#125;);&#125;</code></pre></li><li><p>七、一些特殊方法</p><ol><li><p>栅栏方法 dispatch_barrier_async</p><p>dispatch_barrier_async 函数会等待前边追加到并发队列中的任务全部执行完毕之后，再将指定的任务追加到该异步队列中。 后在 dispatch_barrier_async 函数追加的任务执行完毕之后，异步队列才恢复为一般动作，接着追加任务到该异步队列并开始执行。</p></li><li><p>延时方法 dispatch_after</p><p>dispatch_after 函数并不是在指定时间之后才开始执行处理，而是在指定时间之后将任务追加到主队列中。<br>严格来说，这个时间并不是绝对准确的，但想要大致延迟执行任务，dispatch_after函数是很有效的</p></li><li><p>只执行一次代码 dispatch_once</p><p>使用 dispatch_once 函数能保证某段代码在程序运行过程中只被执行一次，并且即使多线程的环境下，dispatch_once 也可以保证线程安全</p></li><li><p>快速迭代方法 dispatch_apply</p><p>dispatch_apply按照指定的次数将指定的任务追加到指定的队列中，并等待全部队列执行结束。</p><p><em>还可以利用异步队列同时遍历，例如： 遍历0-5 这6个数字，for循环的做法是每次取出一个元素，逐个遍历。而dispatch_apply 可以同时遍历多个数字</em></p></li><li><p>队列组 dispatch_group</p><ol><li>调用队列组的 dispatch_group_async 先把任务放到队列中，然后将队列放入队列组中。或者使用队列组的 dispatch_group_enter、dispatch_group_leave 组合 来实现 dispatch_group_async。  </li><li>调用队列组的 dispatch_group_notify 回到指定线程执行任务。或者使用 dispatch_group_wait 回到当前线程继续向下执行（会阻塞当前线程）。例如一个下载器中有多个下载任务*</li></ol></li><li><p>信号量 dispatch_semaphore</p><p>在dispatch_semaphore中，使用计数来完成这个功能，计数为0时等待，不可通过。计数为1或大于1时，计数减1且不等待，可通过。</p><ol><li>dispatch_semaphore_create: 创建一个Semaphore并初始化信号的总量  2. </li><li>dispatch_semaphore_signal: 发送一个信号，让信号总量加1  3. </li><li>dispatch_semaphore_wait: 可以使总信号量减1，当信号总量为0时，就会一直等待（阻塞所在线程），否则就可以正常执行。</li></ol><p><strong>信号量在开发中的实际用途</strong>：</p><ol><li>保持线程同步，将异步执行任务转换为同步执行任务</li><li>保证线程安全，为线程加锁</li></ol></li></ol></li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Gulp优化Hexo博客访问速度</title>
      <link href="/2019/05/09/Gulp%E4%BC%98%E5%8C%96hexo%E5%8D%9A%E5%AE%A2%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6/"/>
      <url>/2019/05/09/Gulp%E4%BC%98%E5%8C%96hexo%E5%8D%9A%E5%AE%A2%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="Hexo博客访问过慢"><a href="#Hexo博客访问过慢" class="headerlink" title="Hexo博客访问过慢"></a>Hexo博客访问过慢</h2><p>由于Hexo博客托管在github上，导致国内访问有点问题。</p><h2 id="Gulp"><a href="#Gulp" class="headerlink" title="Gulp"></a>Gulp</h2><p>Gulp是一个构建工具，能够优化&amp;压缩资源。</p><h2 id="使用Gulp优化"><a href="#使用Gulp优化" class="headerlink" title="使用Gulp优化"></a>使用Gulp优化</h2><p>首先配置安装gulp，Mac用户要加<code>sudo</code>，为了能全局使用加<code>-g</code>:<br><code>sudo npm install gulp -g</code><br><br><br>然后再博客的根目录添加<code>gulpfile.js</code>文件，内容如下:<br><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> gulp = <span class="hljs-built_in">require</span>(<span class="hljs-string">'gulp'</span>),    uglify = <span class="hljs-built_in">require</span>(<span class="hljs-string">'gulp-uglify'</span>),    rename = <span class="hljs-built_in">require</span>(<span class="hljs-string">'gulp-rename'</span>),    cssmin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'gulp-minify-css'</span>),    imagemin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'gulp-imagemin'</span>);<span class="hljs-comment">//JS压缩</span>gulp.task(<span class="hljs-string">'uglify'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> gulp.src(<span class="hljs-string">'././public/js/*.js'</span>)        .pipe(uglify())        .pipe(gulp.dest(<span class="hljs-string">'././public/js/'</span>));&#125;);<span class="hljs-comment">//public-fancybox-js压缩</span>gulp.task(<span class="hljs-string">'fancybox:js'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> gulp.src(<span class="hljs-string">'././public/fancybox/jquery.fancybox.js'</span>)        .pipe(uglify())        .pipe(gulp.dest(<span class="hljs-string">'././public/fancybox/'</span>));&#125;);<span class="hljs-comment">//public-fancybox-css压缩</span>gulp.task(<span class="hljs-string">'fancybox:css'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> gulp.src(<span class="hljs-string">'././public/fancybox/jquery.fancybox.css'</span>)        .pipe(cssmin())        .pipe(gulp.dest(<span class="hljs-string">'././public/fancybox/'</span>));&#125;);<span class="hljs-comment">//CSS压缩</span>gulp.task(<span class="hljs-string">'cssmin'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> gulp.src(<span class="hljs-string">'././public/css/style.css'</span>)        .pipe(cssmin())        .pipe(gulp.dest(<span class="hljs-string">'././public/css/'</span>));&#125;);<span class="hljs-comment">//图片压缩</span>gulp.task(<span class="hljs-string">'images'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    gulp.src(<span class="hljs-string">'././public/img/*.*'</span>)        .pipe(imagemin(&#123;            <span class="hljs-attr">progressive</span>: <span class="hljs-literal">false</span>        &#125;))        .pipe(gulp.dest(<span class="hljs-string">'././public/img/'</span>));&#125;);gulp.task(<span class="hljs-string">'build'</span>, [<span class="hljs-string">'uglify'</span>, <span class="hljs-string">'cssmin'</span>, <span class="hljs-string">'images'</span>, <span class="hljs-string">'fancybox:js'</span>, <span class="hljs-string">'fancybox:css'</span>]);</code></pre></p><p>最后输入命令<code>gulp</code>加载配置，可能会遇到如下报错信息：<br><br><br>1、<br><pre><code class="hljs bash">internal/modules/cjs/loader.js:583    throw err;    ^Error: Cannot find module <span class="hljs-string">'gulp-uglify'</span>    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:581:15)    at Function.Module._load (internal/modules/cjs/loader.js:507:25)    at Module.require (internal/modules/cjs/loader.js:637:17)    at require (internal/modules/cjs/helpers.js:22:18)    at Object.&lt;anonymous&gt; (/Users/zhangwenxuan/hexo1/gulpfile.js:2:14)    at Module._compile (internal/modules/cjs/loader.js:689:30)    at Object.Module._extensions..js (internal/modules/cjs/loader.js:700:10)    at Module.load (internal/modules/cjs/loader.js:599:32)    at tryModuleLoad (internal/modules/cjs/loader.js:538:12)    at Function.Module._load (internal/modules/cjs/loader.js:530:3)</code></pre></p><p>解决方案：通过<code>sudo npm install --save-dev gulp-uglify</code>安装缺失的包。<br><br><br>2、<br><code>AssertionError [ERR_ASSERTION]: Task function must be specified</code><br><br><br>解决方案：将本地的gulp版本调到3.9.0。进入博客根目录下的<code>package.json</code>，更改为<code>&quot;gulp&quot;: &quot;^3.9.0&quot;</code>，之后运行<code>npm install</code>。</p><h2 id="上传博客"><a href="#上传博客" class="headerlink" title="上传博客"></a>上传博客</h2><pre><code class="hljs bash"><span class="hljs-variable">$hexo</span> cl<span class="hljs-variable">$hexo</span> g<span class="hljs-variable">$gulp</span> build<span class="hljs-variable">$hexo</span> d</code></pre><p>或者<br><pre><code class="hljs bash"><span class="hljs-variable">$hexo</span> cl &amp;&amp; hexo g &amp;&amp; gulp build &amp;&amp; hexo d</code></pre></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Java反射——框架设计的灵魂</title>
      <link href="/2019/04/29/Java%E5%8F%8D%E5%B0%84%E2%80%94%E2%80%94%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E7%81%B5%E9%AD%82/"/>
      <url>/2019/04/29/Java%E5%8F%8D%E5%B0%84%E2%80%94%E2%80%94%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E7%81%B5%E9%AD%82/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h2><ul><li>Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。</li><li>想要解剖一个类，必须先要获取到该类的字节码文件对象，解剖使用的就是 Class 类中的方法，所以先要获取到每一个字节码文件对应的 Class 类型的对象。</li></ul><h2 id="反射的使用"><a href="#反射的使用" class="headerlink" title="反射的使用"></a>反射的使用</h2><p>拿测试用的 Student 类来做个演示<br><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;    <span class="hljs-keyword">public</span> String name;    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">char</span> sex;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123; <span class="hljs-keyword">this</span>.age = age; &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age; &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.out.println(<span class="hljs-string">"Main Function"</span>);    &#125;    <span class="hljs-comment">//默认构造方法</span>    Student(<span class="hljs-keyword">int</span> m) &#123;        System.out.println(<span class="hljs-string">"默认构造方法"</span>);    &#125;    <span class="hljs-comment">//无参构造方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"Student's constructing"</span>);    &#125;    <span class="hljs-comment">//一个参数的构造方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;        System.out.println(<span class="hljs-string">"姓名："</span> + name);    &#125;    <span class="hljs-comment">//两个参数的构造函数</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name ,<span class="hljs-keyword">int</span> age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.age = age;        System.out.println(<span class="hljs-string">"姓名："</span> + name + <span class="hljs-string">"年龄："</span> + age);    &#125;    <span class="hljs-comment">//受保护的构造方法</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> n)</span> </span>&#123;        System.out.println(<span class="hljs-string">"受保护的构造方法 n = "</span> + n);    &#125;    <span class="hljs-comment">//私有的构造方法</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-keyword">char</span> x)</span></span>&#123;        System.out.println(<span class="hljs-string">"私有的构造方法 性别："</span> + x);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printStudens</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"student's name: "</span> + name);    &#125;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">protectedFnc</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">"受保护方法"</span>); &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">defaultFnc</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">"默认方法"</span>); &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">privateFnc</span><span class="hljs-params">()</span> </span>&#123; System.out.println(<span class="hljs-string">"私有方法"</span>); &#125;&#125;</code></pre></p><p>类中包含了构造函数、成员变量、成员函数、main函数</p><ul><li>首先要获取到 Class 对象，有如下三种方式:<br><br><pre><code class="hljs Java"><span class="hljs-comment">// 1</span>Student stu1 = <span class="hljs-keyword">new</span> Student();Class stu1Class = stu1.getClass();System.out.println(stu1Class.getName());<span class="hljs-comment">// 2</span>Class stu2Class = Student.class;System.out.println(stu2Class.getName());<span class="hljs-comment">// 3</span><span class="hljs-keyword">try</span> &#123;    Class stu3Class = Class.forName(<span class="hljs-string">"Reflection.Student"</span>);    System.out.println(stu3Class.getName());&#125;<span class="hljs-keyword">catch</span> (ClassNotFoundException e)&#123;    e.printStackTrace();&#125;</code></pre></li></ul><p><strong><em>&emsp;&emsp;&emsp;&emsp;第一种方式无法体现反射的作用，第二种方式对于包的依赖过强，第三种方式常用。</em></strong></p><ul><li><p>反射获取构造函数<br><br></p><pre><code class="hljs Java"><span class="hljs-comment">// 获取公有构造方法</span>Constructor[] conArray = clazz.getConstructors();<span class="hljs-keyword">for</span> (Constructor c : conArray) &#123;    System.out.println(c);&#125;<span class="hljs-comment">// 获取所有构造方法</span>conArray = clazz.getDeclaredConstructors();<span class="hljs-keyword">for</span> (Constructor c : conArray) &#123;    System.out.println(c);&#125;<span class="hljs-comment">// 获取公有、无参构造方法</span>Constructor con = clazz.getConstructor(<span class="hljs-keyword">null</span>);<span class="hljs-comment">// 调用构造方法</span>Object obj = con.newInstance();<span class="hljs-comment">// 获取私有构造方法</span>con = clazz.getDeclaredConstructor(<span class="hljs-keyword">char</span>.class);<span class="hljs-comment">// 调用构造方法</span><span class="hljs-comment">// 暴力访问(忽略访问修饰符)</span>con.setAccessible(<span class="hljs-keyword">true</span>);obj = con.newInstance(<span class="hljs-string">'男'</span>);</code></pre></li><li><p>反射获取成员变量<br><br></p><pre><code class="hljs Java"><span class="hljs-comment">// 所有公有成员变量</span>Field[] fieldArray = clazz.getFields();<span class="hljs-keyword">for</span> (Field f : fieldArray) &#123;    System.out.println(f);&#125;<span class="hljs-comment">// 所有成员变量</span>fieldArray = clazz.getDeclaredFields();<span class="hljs-keyword">for</span> (Field f : fieldArray) &#123;    System.out.println(f);&#125;<span class="hljs-comment">// 公有成员变量</span>Field f = clazz.getField(<span class="hljs-string">"name"</span>);System.out.println(f);<span class="hljs-comment">// 获取一个对象</span>Object obj = clazz.getConstructor().newInstance();f.set(obj ,<span class="hljs-string">"zwx"</span>);Student stu = (Student)obj;System.out.println(<span class="hljs-string">"验证姓名："</span> + stu.name);<span class="hljs-comment">// 私有成员变量</span>f = clazz.getDeclaredField(<span class="hljs-string">"age"</span>);System.out.println(f);<span class="hljs-comment">// 暴力反射，解除私有限定</span>f.setAccessible(<span class="hljs-keyword">true</span>);f.set(obj ,<span class="hljs-number">22</span>);</code></pre></li><li><p>反射获取成员函数<br><br></p><pre><code class="hljs Java"><span class="hljs-comment">// 所有公有方法</span>Method[] methodArray = clazz.getMethods();<span class="hljs-keyword">for</span> (Method m : methodArray) &#123;    System.out.println(m);&#125;<span class="hljs-comment">// 所有方法</span>methodArray = clazz.getDeclaredMethods();<span class="hljs-keyword">for</span> (Method m : methodArray) &#123;    System.out.println(m);&#125;<span class="hljs-comment">// 公有方法</span>Method m = clazz.getMethod(<span class="hljs-string">"printStudens"</span>);System.out.println(m);Object obj = clazz.getConstructor().newInstance();m.invoke(obj);<span class="hljs-comment">// 私有方法</span>m = clazz.getDeclaredMethod(<span class="hljs-string">"privateFnc"</span>);System.out.println(m);m.setAccessible(<span class="hljs-keyword">true</span>);m.invoke(obj);</code></pre></li><li><p>反射获取 main 函数<br><br></p><pre><code class="hljs Java">Method methodMain = clazz.getMethod(<span class="hljs-string">"main"</span>,String[].class);methodMain.invoke(<span class="hljs-keyword">null</span> ,(Object)<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">"a"</span>,<span class="hljs-string">"b"</span>&#125;);</code></pre></li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>SSH远程登录Mac</title>
      <link href="/2019/04/26/SSH%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95Mac/"/>
      <url>/2019/04/26/SSH%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95Mac/</url>
      
        <content type="html"><![CDATA[<ol><li><p>macOS的Terminal自带ssh，可通过whereis查看:<code>whereis ssh</code>。</p></li><li><p>启用SSHD服务<br>进入“系统偏好设置(System Preferences)”-&gt;选择“共享(Sharing)”-&gt;勾选“远程登录(Remote Login)”<br><br>完成后可用<code>ssh localhost</code>进行测试，如果提示输入密码认证就没问题了。</p></li><li><p>SSH和SCP</p><ul><li>ssh连接其他主机：<br><br><code>ssh username@192.168.1.1</code><br><br>username为要登录的主机名,192.168.1.1为要登录主机的IP地址</li><li>scp文件传输<br><br>scp的简单使用如下:<br><br><code>scp filename username@192.168.1.1:/tmp</code><br><br><strong> 不过一开始我没有传到/tmp目录下，遇到了Permission denied的问题， </strong><br><br>查了一些资料发现可能是那个目录没有操作权限的问题，默认的操作权限在/tmp目录下。</li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Vue常用属性</title>
      <link href="/2019/04/23/Vue%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7/"/>
      <url>/2019/04/23/Vue%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue-js的7个常用属性"><a href="#Vue-js的7个常用属性" class="headerlink" title="Vue.js的7个常用属性"></a>Vue.js的7个常用属性</h2><ul><li>el<br><em>用来指示vue编译器从什么地方开始解析 vue的语法，可以说是一个占位符。</em></li><li>data<br><em>用来组织从view中抽象出来的属性，可以说将视图的数据抽象出来存放在data中。</em></li><li>template<br><em>用来设置模板，会替换页面元素，包括占位符。</em></li><li>methods<br><em>页面的业务逻辑，存放js方法</em></li><li>render<br><em>创建虚拟DOM</em></li><li>computed<br><em>计算属性</em></li><li>watch<br><em><code>watch:function(newValue,oldValue){}</code><br>监听data中数据的变化，参数包含旧值和新值</em></li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>div的父子关系</title>
      <link href="/2019/04/21/div%E7%9A%84%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB/"/>
      <url>/2019/04/21/div%E7%9A%84%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="子div有内容，父div的高度为何为0？"><a href="#子div有内容，父div的高度为何为0？" class="headerlink" title="子div有内容，父div的高度为何为0？"></a>子div有内容，父div的高度为何为0？</h2><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">        <span class="hljs-selector-class">.a</span>&#123;                <span class="hljs-attribute">background-color</span>: orange;        &#125;        <span class="hljs-selector-class">.b</span>&#123;            <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;            <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;            <span class="hljs-attribute">background-color</span>: blue;            <span class="hljs-attribute">float</span>: left;        &#125;    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"a"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"b"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>效果图:<br><img src="/2019/04/21/div的父子关系/diva.png" srcset="/img/loading.gif" alt="div a"><br>一个父视图包含一个子视图，子div有高度，父div高度为0</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>当一个元素只包含浮动元素的时候，它会出现高度折叠,即元素的上下底边重合，和高度为0效果一样。</p><p>当子div用绝对定位时<br><pre><code class="hljs html">.b&#123;    height: 50px;    width: 50px;    background-color: blue;    position: absolute;    left: 70%;&#125;</code></pre></p><p>父div高度j依旧为0，因为子元素绝对定位脱离文档流，不会撑开父元素，父元素高度为0。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>overflow的hidden属性<br>父div添加overflow的hidden属性</li><li>添加一个空的div<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"a"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"b"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"clear: both;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></li></ul><p><strong>这种方法是添加一个空的div，这个div和浮动元素同一级别，且位于浮动元素的最后。它在这里并不具有实际意义，它的作用只是撑开div标签而已。</strong></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>GRE整理</title>
      <link href="/2019/01/14/GRE%E6%95%B4%E7%90%86/"/>
      <url>/2019/01/14/GRE%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="GRE"><a href="#GRE" class="headerlink" title="GRE"></a>GRE</h1><p><em>19年1月14日起的GRE学习和复习笔记</em><br><em>顺带准备雅思第二次考试</em><br><strong>第一次考试计划时间：19年2月末三月初</strong> </p><hr><h2 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h2><ul><li>GRE考试官方指南第三版</li><li>黑宝书</li><li>杨鹏长难句教程</li></ul><h2 id="GRE的考试架构"><a href="#GRE的考试架构" class="headerlink" title="GRE的考试架构"></a>GRE的考试架构</h2><p><em>机考总时长约为3小时45分钟</em></p><ol><li><p>Analytical Writing 分析性写作 6分<br><strong>清楚有效地阐明和支持复杂观点，考察其他观点及论证</strong><br>两篇作文，Issue（立论文）和Argument（驳论文），每篇30分钟，共60分钟。</p></li><li><p>Verbal Reasoning 文字推理 170分<br><strong>分析和评估书面材料，综合材料信息，可以理解为传统的阅读理解</strong><br>2*20道题，每部分30分钟，共60分钟。</p></li></ol><ul><li>Reading Comprehension 阅读理解<br>单选、多选和选句子</li><li>Text Completion 段落完形填空<br>完型</li><li>Sentence Equivalence 同义句填空<br>六选二，选出两个合适的同义词填在句子中</li></ul><ol start="3"><li>Quantitative Reasoning 数量推理 170分<br><strong>基本的数学技能，对算数、代数和几何的基本数学概念的理解，数据分析</strong><br>2*20道题，每部分35分钟，共70分钟。<strong>有屏幕计算器功能</strong></li></ol><ul><li>Quantitative Comparison questions 数量比较题</li><li>Multiple-choice questions–Select One Answer Choice 单选题</li><li>Multiple-choice questions–Select One or More Answer Choices 多选题</li><li>Numeric Entry questions 数字填空题</li></ul><ol start="4"><li>Unscored 不计分部分<br>20题</li></ol><h2 id="复习规划"><a href="#复习规划" class="headerlink" title="复习规划"></a>复习规划</h2><ul><li>准备周期：六到八周<br><strong>第1-2周</strong>    1.14—1.27   每天做OG&gt;=2组的阅读和数学，黑宝书3个list。<strong>单词是关键</strong><br><strong>第3周</strong>       1.27—2.3     每天背2个list，杨鹏长难句教程，OG题&gt;=3组。<br><strong>第4周</strong>       2.4—2.10     每天尽力做section，后半段进入数学准备，看钱永强第二三部分逻辑解题方法。<br><strong>第5周</strong>       2.10—2.17   背单词本生僻字，继续钱永强，做精选LSAT逻辑组题。<br><strong>第6周</strong>       2.17—2.24   上午太傻类比反义大全，PP2 review填空大部分是重题，做题+总结。<br><strong>第7周</strong>       2.24—3.3     黑宝书每天过，看机经，练习。</li></ul><h2 id="每日迭代"><a href="#每日迭代" class="headerlink" title="每日迭代"></a>每日迭代</h2><p>2019-01.14      列计划，整理资料</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>iOS开发页面传值的四种方式</title>
      <link href="/2018/12/21/iOS-valuePass-1/"/>
      <url>/2018/12/21/iOS-valuePass-1/</url>
      
        <content type="html"><![CDATA[<h1 id="iOS开发页面传值的四种方式"><a href="#iOS开发页面传值的四种方式" class="headerlink" title="iOS开发页面传值的四种方式"></a>iOS开发页面传值的四种方式</h1><p><em>前两天帮同学用swift解决了Block和代理传值，想到还没整理过OC的页面传值，原理都一样只是语法上的差异</em></p><hr><h3 id="一、属性传值"><a href="#一、属性传值" class="headerlink" title="一、属性传值"></a>一、属性传值</h3><p><strong>适合情况</strong>：页面A向页面B传值<br><strong>步骤</strong>：<br>1、B_VC.h中声明一个textString属性，用于接收传来的字符串<br><pre><code class="hljs bash"><span class="hljs-comment">#import &lt;UIKit/UIKit.h&gt;</span>NS_ASSUME_NONNULL_BEGIN@interface B_VC : UIViewController@property (nonatomic , strong) NSString *textString;@endNS_ASSUME_NONNULL_END</code></pre></p><p>m中创建label用于显示<br><pre><code class="hljs bash">- (void) propertyValuePass&#123;    UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(SCREEN_WIDTH*0.25, SCREEN_HEIGHT*0.15, SCREEN_WIDTH*0.5, SCREEN_HEIGHT*0.05)];    label.backgroundColor = [UIColor purpleColor];    label.textColor = [UIColor whiteColor];    label.textAlignment = NSTextAlignmentCenter;    label.font = [UIFont systemFontOfSize:20];    label.numberOfLines = 0;    label.text = self.textString;    [self.view addSubview:label];&#125;</code></pre></p><p>2、A_VC中创建输入框和跳转按钮<br><pre><code class="hljs bash"><span class="hljs-comment">#import "A_VC.h"</span><span class="hljs-comment">#import "B_VC.h"</span><span class="hljs-comment">#define SCREEN_WIDTH ([[UIScreen mainScreen] bounds].size.width)</span><span class="hljs-comment">#define SCREEN_HEIGHT ([[UIScreen mainScreen] bounds].size.height)</span>@interface A_VC ()@property(nonatomic , strong) UITextField *textField;@end@implementation A_VC- (void) viewDidLoad &#123;    [super viewDidLoad];    //输入框    self.textField = [[UITextField alloc] initWithFrame:CGRectMake(SCREEN_WIDTH*0.25, SCREEN_HEIGHT*0.15, SCREEN_WIDTH*0.5, SCREEN_HEIGHT*0.05)];    self.textField.backgroundColor = [UIColor purpleColor];    self.textField.placeholder = @<span class="hljs-string">"属性传值"</span>;    self.textField.textAlignment = NSTextAlignmentCenter;    self.textField.textColor = [UIColor whiteColor];    [self.view addSubview:self.textField];    // 创建一个轻拍手势，当点击屏幕任何一个地方，就取消键盘的第一响应，隐藏键盘    UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(handleTap:)];    [self.view addGestureRecognizer:tap];    //跳转按钮    UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom];    button.frame = CGRectMake(SCREEN_WIDTH*0.25, SCREEN_HEIGHT*0.23, SCREEN_WIDTH*0.5, SCREEN_HEIGHT*0.05);    [button setTitle:@<span class="hljs-string">"下一页"</span> forState:UIControlStateNormal];    button.titleLabel.font = [UIFont systemFontOfSize:20];    button.backgroundColor = [UIColor purpleColor];    [button addTarget:self action:@selector(clickAction:) forControlEvents:UIControlEventTouchUpInside];    [self.view addSubview:button];&#125;//放弃作为第一响应者- (void) handleTap:(id)sender &#123;    [self.textField resignFirstResponder];&#125;//页面跳转-(void) clickAction:(id)sender &#123;    //从storyboard拿页面    UIStoryboard *sb = [UIStoryboard storyboardWithName:@<span class="hljs-string">"Main"</span> bundle:[NSBundle mainBundle]];    B_VC *B = [sb instantiateViewControllerWithIdentifier:@<span class="hljs-string">"B"</span>];    B.textString = self.textField.text;    [self.navigationController pushViewController:B animated:YES];&#125;@end</code></pre></p><p>效果</p><center class="half"><br><img src="/2018/12/21/iOS-valuePass-1/A1.png" srcset="/img/loading.gif" height="330" width="190"><img src="/2018/12/21/iOS-valuePass-1/B1.png" srcset="/img/loading.gif" height="330" width="190"><br></center><p><strong>属性传值的核心就是在一个页面通过使用另一个页面的属性，利用这个属性来保存需要传递的信息，从而达到在另一个页面能使用前一个页面传递过来的信息。</strong></p><h3 id="二、Block传值"><a href="#二、Block传值" class="headerlink" title="二、Block传值"></a>二、Block传值</h3><p><strong>适合情况</strong>：页面B向页面A传值<br><strong>步骤</strong>：<br>1、A页面创建一个用于显示B页面输入内容的label</p><pre><code class="hljs bash"><span class="hljs-comment">#import &lt;UIKit/UIKit.h&gt;</span>NS_ASSUME_NONNULL_BEGIN@interface A_VC2 : UIViewController@property (nonatomic,retain) UILabel *label;@endNS_ASSUME_NONNULL_END</code></pre><p>2、B页面的.h文件里创建一个用于传值的Block，一个Block方法和一个textfield<br><pre><code class="hljs bash"><span class="hljs-comment">#import &lt;UIKit/UIKit.h&gt;</span>NS_ASSUME_NONNULL_BEGINtypedef void (^ReturnTextBlock)(NSString *showText);@interface B_VC2 : UIViewController@property (nonatomic,retain) UITextField *tf;@property (nonatomic,copy) ReturnTextBlock returnTextBlock;//定义的一个Block属性- (void)returnText:(ReturnTextBlock)block;@endNS_ASSUME_NONNULL_END</code></pre></p><p>3、将传递过来的block赋值给自己的属性block，然后找一个时机给block传递数据，这里选取页面将要消失时传值<br><pre><code class="hljs bash"><span class="hljs-comment">#import "B_VC2.h"</span><span class="hljs-comment">#define SCREEN_WIDTH ([[UIScreen mainScreen] bounds].size.width)</span><span class="hljs-comment">#define SCREEN_HEIGHT ([[UIScreen mainScreen] bounds].size.height)</span>@interface B_VC2 ()@end@implementation B_VC2- (void)viewDidLoad &#123;    [super viewDidLoad];    //定义一个输入框 将文字传给第一个界面，并且显示在前一个页面的UILabel上    self.tf = [[UITextField alloc]initWithFrame:CGRectMake(SCREEN_WIDTH*0.25, SCREEN_HEIGHT*0.15, SCREEN_WIDTH*0.5, SCREEN_HEIGHT*0.05)];    self.tf.backgroundColor = [UIColor blackColor];    self.tf.textColor = [UIColor whiteColor];    self.tf.textAlignment = NSTextAlignmentCenter;    self.tf.placeholder = @<span class="hljs-string">"请输入内容"</span>;    [self.view addSubview:self.tf];&#125;/*在第一个界面传进来一个Block语句块的函数，把传进来的Block语句块保存到本类的实例变量returnTextBlock（.h中定义的属性）中，然后寻找一个时机调用*/-(void)returnText:(ReturnTextBlock)block&#123;    self.returnTextBlock = block;&#125;//而这个时机就是当视图将要消失的时候，需要重写：-(void)viewWillDisappear:(BOOL)animated&#123;    <span class="hljs-keyword">if</span> (self.returnTextBlock !=nil) &#123;    self.returnTextBlock(self.tf.text);    &#125;&#125;@end</code></pre></p><p>3、A页面c读取Blockd传递的数据并显示，要注意在跳转处赋值<br><pre><code class="hljs bash"><span class="hljs-comment">#import "A_VC2.h"</span><span class="hljs-comment">#import "B_VC2.h"</span><span class="hljs-comment">#define SCREEN_WIDTH ([[UIScreen mainScreen] bounds].size.width)</span><span class="hljs-comment">#define SCREEN_HEIGHT ([[UIScreen mainScreen] bounds].size.height)</span>@interface A_VC2 ()@end@implementation A_VC2- (void)viewDidLoad &#123;    [super viewDidLoad];    //跳转按钮    UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom];    button.frame = CGRectMake(SCREEN_WIDTH*0.25, SCREEN_HEIGHT*0.23, SCREEN_WIDTH*0.5, SCREEN_HEIGHT*0.05);    button.backgroundColor = [UIColor blackColor];    button.titleLabel.textColor = [UIColor whiteColor];    [button setTitle:@<span class="hljs-string">"下一页"</span> forState:UIControlStateNormal];    [button addTarget:self action:@selector(clickAction:) forControlEvents:UIControlEventTouchUpInside];    [self.view addSubview:button];    //label    self.label = [[UILabel alloc] initWithFrame:CGRectMake(SCREEN_WIDTH*0.25, SCREEN_HEIGHT*0.15, SCREEN_WIDTH*0.5, SCREEN_HEIGHT*0.05)];    self.label.backgroundColor = [UIColor blackColor];    self.label.textColor = [UIColor whiteColor];    self.label.textAlignment = NSTextAlignmentCenter;    [self.view addSubview:self.label];&#125;- (void) clickAction:(id)sender&#123;    //从storyboard拿页面    UIStoryboard *sb = [UIStoryboard storyboardWithName:@<span class="hljs-string">"Main"</span> bundle:[NSBundle mainBundle]];    B_VC2 *B = [sb instantiateViewControllerWithIdentifier:@<span class="hljs-string">"B2"</span>];    //跳转处赋值    [B returnText:^(NSString * _Nonnull showText) &#123;    self.label.text = showText;    &#125;];    [self.navigationController pushViewController:B animated:YES];&#125;@end</code></pre></p><p>效果</p><center class="half"><br><img src="/2018/12/21/iOS-valuePass-1/A2.png" srcset="/img/loading.gif" height="330" width="190"><img src="/2018/12/21/iOS-valuePass-1/B2.png" srcset="/img/loading.gif" height="330" width="190"><br></center><p><strong>Block传值是将值保存在代码块中，通过关联传递过来的代码块（页面一）与自己的属性代码块（页面二），以及使用代码块传值（页面二），回到页面一中，页面一回调代码块，以获取代码块传递过来的值。</strong></p>]]></content>
      
      
      
    </entry>
    
  
  
</search>
